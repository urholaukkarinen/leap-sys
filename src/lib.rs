/* automatically generated by rust-bindgen 0.60.1 */

pub const LEAP_DISTORTION_MATRIX_N: u32 = 64;
#[doc = " The operation completed successfully."]
pub const _eLeapRS_eLeapRS_Success: _eLeapRS = 0;
#[doc = " An undetermined error has occurred."]
#[doc = " This is usually the result of an abnormal operating condition in LeapC,"]
#[doc = " the Ultraleap Tracking Service, or the host computer itself."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_UnknownError: _eLeapRS = -503250944;
#[doc = " An invalid argument was specified."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_InvalidArgument: _eLeapRS = -503250943;
#[doc = " Insufficient resources existed to complete the request."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_InsufficientResources: _eLeapRS = -503250942;
#[doc = " The specified buffer was not large enough to complete the request."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_InsufficientBuffer: _eLeapRS = -503250941;
#[doc = " The requested operation has timed out."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_Timeout: _eLeapRS = -503250940;
#[doc = " The operation is invalid because there is no current connection."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_NotConnected: _eLeapRS = -503250939;
#[doc = " The operation is invalid because the connection is not complete."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_HandshakeIncomplete: _eLeapRS = -503250938;
#[doc = " The specified buffer size is too large."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_BufferSizeOverflow: _eLeapRS = -503250937;
#[doc = " A communications protocol error occurred."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_ProtocolError: _eLeapRS = -503250936;
#[doc = " The server incorrectly specified zero as a client ID."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_InvalidClientID: _eLeapRS = -503250935;
#[doc = " The connection to the service was unexpectedly closed while reading or writing a message."]
#[doc = " The server may have terminated."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_UnexpectedClosed: _eLeapRS = -503250934;
#[doc = " The specified request token does not appear to be valid"]
#[doc = ""]
#[doc = " Provided that the token value which identifies the request itself was, at one point, valid, this"]
#[doc = " error condition occurs when the request to which the token refers has already been satisfied or"]
#[doc = " is currently being satisfied."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_UnknownImageFrameRequest: _eLeapRS = -503250933;
#[doc = " The specified frame ID is not valid or is no longer valid"]
#[doc = ""]
#[doc = " Provided that frame ID was, at one point, valid, this error condition occurs when the identifier"]
#[doc = " refers to a frame that occurred further in the past than is currently recorded in the rolling"]
#[doc = " frame window."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_UnknownTrackingFrameID: _eLeapRS = -503250932;
#[doc = " The specified timestamp references a future point in time"]
#[doc = ""]
#[doc = " The related routine can only operate on time points having occurred in the past, and the"]
#[doc = " provided timestamp occurs in the future."]
#[doc = " @since 3.1.2"]
pub const _eLeapRS_eLeapRS_RoutineIsNotSeer: _eLeapRS = -503250931;
#[doc = " The specified timestamp references a point too far in the past"]
#[doc = ""]
#[doc = " The related routine can only operate on time points occurring within its immediate record of"]
#[doc = " the past."]
#[doc = " @since 3.1.2"]
pub const _eLeapRS_eLeapRS_TimestampTooEarly: _eLeapRS = -503250930;
#[doc = " LeapPollConnection is called concurrently."]
#[doc = " @since 3.1.2"]
pub const _eLeapRS_eLeapRS_ConcurrentPoll: _eLeapRS = -503250929;
#[doc = " A connection to the Ultraleap Tracking Service could not be established."]
#[doc = "@since 3.0.0"]
pub const _eLeapRS_eLeapRS_NotAvailable: _eLeapRS = -419364862;
#[doc = " The requested operation can only be performed while the device is sending data."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_NotStreaming: _eLeapRS = -419364860;
#[doc = " The specified device could not be opened. It is possible that the device identifier"]
#[doc = " is invalid, or that the device has been disconnected since being enumerated."]
#[doc = " @since 3.0.0"]
pub const _eLeapRS_eLeapRS_CannotOpenDevice: _eLeapRS = -419364859;
#[doc = " The request is not supported by this version of the service."]
#[doc = " @since 5.4.0"]
pub const _eLeapRS_eLeapRS_Unsupported: _eLeapRS = -419364858;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the codes returned by all LeapC functions."]
#[doc = " @since 3.0.0"]
pub type _eLeapRS = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the codes returned by all LeapC functions."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapRS as eLeapRS;
#[doc = " The tracking mode optimised for desktop devices @since 5.0.0"]
pub const _eLeapTrackingMode_eLeapTrackingMode_Desktop: _eLeapTrackingMode = 0;
#[doc = " The tracking mode optimised for head-mounted devices @since 5.0.0"]
pub const _eLeapTrackingMode_eLeapTrackingMode_HMD: _eLeapTrackingMode = 1;
#[doc = " The tracking mode optimised for screen top-mounted devices @since 5.0.0"]
pub const _eLeapTrackingMode_eLeapTrackingMode_ScreenTop: _eLeapTrackingMode = 2;
#[doc = " Tracking mode is not known (allows triggering of a new LEAP_TRACKING_MODE_EVENT) @since 5.0.0"]
pub const _eLeapTrackingMode_eLeapTrackingMode_Unknown: _eLeapTrackingMode = 3;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates values for the tracking mode."]
pub type _eLeapTrackingMode = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates values for the tracking mode."]
pub use self::_eLeapTrackingMode as eLeapTrackingMode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONNECTION {
    _unused: [u8; 0],
}
#[doc = " \\ingroup Structs"]
#[doc = " \\struct LEAP_CONNECTION"]
#[doc = " A handle to the Leap connection object."]
#[doc = " Use this handle to specify the connection for an operation."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION = *mut _LEAP_CONNECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE {
    _unused: [u8; 0],
}
#[doc = "  \\ingroup Structs"]
#[doc = " \\struct LEAP_DEVICE"]
#[doc = " A handle to a Leap device object."]
#[doc = " Use this handle to specify the device for an operation."]
#[doc = " @since 3.0.0"]
pub type LEAP_DEVICE = *mut _LEAP_DEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CALIBRATION {
    _unused: [u8; 0],
}
#[doc = "  \\ingroup Structs"]
#[doc = " Represents a calibration object."]
#[doc = " Not currently of any particular use."]
#[doc = " @since 3.0.0"]
pub type LEAP_CALIBRATION = *mut _LEAP_CALIBRATION;
#[doc = "  \\ingroup Structs"]
#[doc = " A reference to a Leap device."]
#[doc = ""]
#[doc = " Get a LEAP_DEVICE_REF by calling LeapGetDeviceList(). Access a device by"]
#[doc = " calling LeapOpenDevice() with this reference. LeapOpenDevice() provides a"]
#[doc = " LEAP_DEVICE struct, which is a handle to an open device."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE_REF {
    #[doc = " An opaque handle. @since 3.0.0"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " a generic identifier. @since 3.0.0"]
    pub id: u32,
}
#[test]
fn bindgen_test_layout__LEAP_DEVICE_REF() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DEVICE_REF>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_DEVICE_REF))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DEVICE_REF>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DEVICE_REF))
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_REF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_REF),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_REF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_REF),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
#[doc = "  \\ingroup Structs"]
#[doc = " A reference to a Leap device."]
#[doc = ""]
#[doc = " Get a LEAP_DEVICE_REF by calling LeapGetDeviceList(). Access a device by"]
#[doc = " calling LeapOpenDevice() with this reference. LeapOpenDevice() provides a"]
#[doc = " LEAP_DEVICE struct, which is a handle to an open device."]
pub type LEAP_DEVICE_REF = _LEAP_DEVICE_REF;
#[doc = " The client is aware of how to handle multiple devices through the API."]
#[doc = " @since 4.1.0"]
pub const _eLeapConnectionConfig_eLeapConnectionConfig_MultiDeviceAware: _eLeapConnectionConfig = 1;
pub type _eLeapConnectionConfig = ::std::os::raw::c_int;
pub use self::_eLeapConnectionConfig as eLeapConnectionConfig;
#[doc = " \\ingroup Structs"]
#[doc = " Specifies the configuration for a connection."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONNECTION_CONFIG {
    #[doc = " Set to the final size of the structure. @since 3.0.0"]
    pub size: u32,
    #[doc = " A combination of eLeapConnectionConfig flags. Set to 0 to indicate no"]
    #[doc = " special flags. @since 3.0.0"]
    pub flags: u32,
    #[doc = " Specifies the server namespace to be used. Leave NULL to use the default namespace."]
    #[doc = ""]
    #[doc = " It is possible to launch the service with a different IPC connection namespace"]
    #[doc = " (using internal service functions). Clients wishing to connect to a different"]
    #[doc = " server namespace may specify that namespace here."]
    #[doc = ""]
    #[doc = " The default connection namespace is \"Leap Service\"."]
    pub server_namespace: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_CONFIG>(),
        16usize,
        concat!("Size of: ", stringify!(_LEAP_CONNECTION_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_CONFIG>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONNECTION_CONFIG))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_CONFIG),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_CONFIG),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_server_namespace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).server_namespace) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_CONFIG),
                "::",
                stringify!(server_namespace)
            )
        );
    }
    test_field_server_namespace();
}
#[doc = " \\ingroup Structs"]
#[doc = " Specifies the configuration for a connection."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION_CONFIG = _LEAP_CONNECTION_CONFIG;
#[doc = " Signed 8-bit integer (char) @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Int8: _eLeapAllocatorType = 0;
#[doc = " Unsigned 8-bit integer (byte) @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Uint8: _eLeapAllocatorType = 1;
#[doc = " Signed 16-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Int16: _eLeapAllocatorType = 2;
#[doc = " Unsigned 16-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_UInt16: _eLeapAllocatorType = 3;
#[doc = " Signed 32-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Int32: _eLeapAllocatorType = 4;
#[doc = " Unsigned 32-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_UInt32: _eLeapAllocatorType = 5;
#[doc = " Single-precision 32-bit floating-point @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Float: _eLeapAllocatorType = 6;
#[doc = " Signed 64-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Int64: _eLeapAllocatorType = 8;
#[doc = " Unsigned 64-bit integer @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_UInt64: _eLeapAllocatorType = 9;
#[doc = " Double-precision 64-bit floating-point @since 4.0.0"]
pub const _eLeapAllocatorType_eLeapAllocatorType_Double: _eLeapAllocatorType = 10;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the various types of data that may be allocated using the allocator."]
#[doc = " @since 4.0.0"]
pub type _eLeapAllocatorType = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the various types of data that may be allocated using the allocator."]
#[doc = " @since 4.0.0"]
pub use self::_eLeapAllocatorType as eLeapAllocatorType;
#[doc = " \\ingroup Structs"]
#[doc = " Specifies the allocator/deallocator functions to be used when the library"]
#[doc = " needs to dynamically manage memory."]
#[doc = " @since 4.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct LEAP_ALLOCATOR {
    #[doc = " Function pointer to an allocator function that is expected to return a"]
    #[doc = " pointer to memory of at least the specified size in bytes. This will be"]
    #[doc = " called when the library needs a block of memory that will be provided"]
    #[doc = " back to the client in a subsequent event or response. A type hint is"]
    #[doc = " provided in the case where the underlying buffer type needs to be known"]
    #[doc = " at allocation time."]
    pub allocate: ::std::option::Option<
        unsafe extern "C" fn(
            size: u32,
            typeHint: eLeapAllocatorType,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Function pointer to a deallocator function. The function receives the"]
    #[doc = " address of a previously allocated block of memory from the ``allocate``"]
    #[doc = " function pointer. The caller is not required to deallocate the memory,"]
    #[doc = " but rather this call is used by the library to indicate to the client"]
    #[doc = " that it will no longer reference the memory at this address, and that"]
    #[doc = " the callee _may_ deallocate the memory when it is ready to do so."]
    pub deallocate: ::std::option::Option<
        unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, state: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Pointer to state to be passed to the allocate and deallocate functions."]
    pub state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_LEAP_ALLOCATOR() {
    assert_eq!(
        ::std::mem::size_of::<LEAP_ALLOCATOR>(),
        24usize,
        concat!("Size of: ", stringify!(LEAP_ALLOCATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<LEAP_ALLOCATOR>(),
        1usize,
        concat!("Alignment of ", stringify!(LEAP_ALLOCATOR))
    );
    fn test_field_allocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<LEAP_ALLOCATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocate) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(LEAP_ALLOCATOR),
                "::",
                stringify!(allocate)
            )
        );
    }
    test_field_allocate();
    fn test_field_deallocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<LEAP_ALLOCATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deallocate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(LEAP_ALLOCATOR),
                "::",
                stringify!(deallocate)
            )
        );
    }
    test_field_deallocate();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<LEAP_ALLOCATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(LEAP_ALLOCATOR),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Samples the universal clock used by the system to timestamp image and tracking frames."]
    #[doc = ""]
    #[doc = " The returned counter value is given in microseconds since an epoch time. The clock used for the"]
    #[doc = " counter itself is implementation-defined, but generally speaking, it is global, monotonic, and"]
    #[doc = " makes use of the most accurate high-performance counter available on the system."]
    #[doc = " @returns microseconds since an unspecified epoch."]
    #[doc = " @since 3.0.0"]
    pub fn LeapGetNow() -> i64;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Creates a new LEAP_CONNECTION object."]
    #[doc = ""]
    #[doc = " Pass the LEAP_CONNECTION pointer to LeapOpenConnection() to establish a"]
    #[doc = " connection to the Ultraleap Tracking Service; and to subsequent operations"]
    #[doc = " on the same connection."]
    #[doc = ""]
    #[doc = " @param pConfig The configuration to be used with the newly created connection."]
    #[doc = " If pConfig is null, a connection is created with a default configuration."]
    #[doc = " @param[out] phConnection Receives a pointer to the connection object, set to invalid on failure"]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapCreateConnection(
        pConfig: *const LEAP_CONNECTION_CONFIG,
        phConnection: *mut LEAP_CONNECTION,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Opens a connection to the service."]
    #[doc = ""]
    #[doc = " This routine will not block. A connection to the service will not be established until the first"]
    #[doc = " invocation of LeapPollConnection."]
    #[doc = ""]
    #[doc = " @param hConnection A handle to the connection object, created by LeapCreateConnection()."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapOpenConnection(hConnection: LEAP_CONNECTION) -> eLeapRS;
}
#[doc = " The service cannot receive frames fast enough from the underlying hardware."]
#[doc = " @since 3.1.3"]
pub const _eLeapServiceDisposition_eLeapServiceState_LowFpsDetected: _eLeapServiceDisposition = 1;
#[doc = " The service has paused itself due to an insufficient frame rate from the hardware."]
#[doc = " @since 3.1.3"]
pub const _eLeapServiceDisposition_eLeapServiceState_PoorPerformancePause:
    _eLeapServiceDisposition = 2;
#[doc = " The service has failed to start tracking due to unknown reasons."]
#[doc = " @since 5.1.16"]
pub const _eLeapServiceDisposition_eLeapServiceState_TrackingErrorUnknown:
    _eLeapServiceDisposition = 4;
#[doc = " The combination of all valid flags in this enumeration"]
pub const _eLeapServiceDisposition_eLeapServiceState_ALL: _eLeapServiceDisposition = 7;
pub type _eLeapServiceDisposition = ::std::os::raw::c_int;
pub use self::_eLeapServiceDisposition as eLeapServiceDisposition;
#[doc = "  \\ingroup Structs"]
#[doc = " Received from LeapPollConnection() when a connection to the Ultraleap Tracking Service is established."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONNECTION_EVENT {
    #[doc = " A combination of eLeapServiceDisposition flags. @since 3.1.3"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_EVENT>(),
        4usize,
        concat!("Size of: ", stringify!(_LEAP_CONNECTION_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONNECTION_EVENT))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_EVENT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[doc = "  \\ingroup Structs"]
#[doc = " Received from LeapPollConnection() when a connection to the Ultraleap Tracking Service is established."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION_EVENT = _LEAP_CONNECTION_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " Received from LeapPollConnection() when a connection to the Ultraleap Tracking Service is lost."]
#[doc = ""]
#[doc = " If a LeapC function that performs a transaction with the Ultraleap Tracking Service is called"]
#[doc = " after the connection is lost, the next call to LeapPollConnection() will return"]
#[doc = " this event. Otherwise, it can take up to 5 seconds of polling the connection to"]
#[doc = " receive this event."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONNECTION_LOST_EVENT {
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_LOST_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_LOST_EVENT>(),
        4usize,
        concat!("Size of: ", stringify!(_LEAP_CONNECTION_LOST_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_LOST_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONNECTION_LOST_EVENT))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_LOST_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_LOST_EVENT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[doc = " \\ingroup Structs"]
#[doc = " Received from LeapPollConnection() when a connection to the Ultraleap Tracking Service is lost."]
#[doc = ""]
#[doc = " If a LeapC function that performs a transaction with the Ultraleap Tracking Service is called"]
#[doc = " after the connection is lost, the next call to LeapPollConnection() will return"]
#[doc = " this event. Otherwise, it can take up to 5 seconds of polling the connection to"]
#[doc = " receive this event."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION_LOST_EVENT = _LEAP_CONNECTION_LOST_EVENT;
#[doc = " The connection is not open."]
#[doc = " Call LeapOpenConnection() to open a connection to the Ultraleap Tracking Service."]
#[doc = " @since 3.0.0"]
pub const _eLeapConnectionStatus_eLeapConnectionStatus_NotConnected: _eLeapConnectionStatus = 0;
#[doc = " The connection is open."]
#[doc = " @since 3.0.0"]
pub const _eLeapConnectionStatus_eLeapConnectionStatus_Connected: _eLeapConnectionStatus = 1;
#[doc = " Opening the connection is underway, but not complete."]
#[doc = " @since 3.0.0"]
pub const _eLeapConnectionStatus_eLeapConnectionStatus_HandshakeIncomplete: _eLeapConnectionStatus =
    2;
#[doc = " The connection could not be opened because the Ultraleap Tracking Service does not"]
#[doc = " appear to be running."]
#[doc = " @since 3.0.0"]
pub const _eLeapConnectionStatus_eLeapConnectionStatus_NotRunning: _eLeapConnectionStatus =
    -419233788;
#[doc = " \\ingroup Enums"]
#[doc = " The connection status codes."]
#[doc = " These codes can be read from the LEAP_CONNECTION_INFO struct created by"]
#[doc = " a call to LeapGetConnectionInfo()."]
#[doc = " @since 3.0.0"]
pub type _eLeapConnectionStatus = ::std::os::raw::c_int;
#[doc = " \\ingroup Enums"]
#[doc = " The connection status codes."]
#[doc = " These codes can be read from the LEAP_CONNECTION_INFO struct created by"]
#[doc = " a call to LeapGetConnectionInfo()."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapConnectionStatus as eLeapConnectionStatus;
#[doc = " \\ingroup Structs"]
#[doc = " Information about a connection."]
#[doc = ""]
#[doc = " Call LeapCreateConnection() to generate the handle for the connection;"]
#[doc = " call LeapOpenConnection() to establish the connection; then call"]
#[doc = " LeapGetConnectionInfo(), which creates this struct, to check the connection status."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONNECTION_INFO {
    #[doc = " The size of this structure. @since 3.0.0"]
    pub size: u32,
    #[doc = " The current status of this connection. @since 3.0.0"]
    pub status: eLeapConnectionStatus,
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(_LEAP_CONNECTION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONNECTION_INFO))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_INFO),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_INFO),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[doc = " \\ingroup Structs"]
#[doc = " Information about a connection."]
#[doc = ""]
#[doc = " Call LeapCreateConnection() to generate the handle for the connection;"]
#[doc = " call LeapOpenConnection() to establish the connection; then call"]
#[doc = " LeapGetConnectionInfo(), which creates this struct, to check the connection status."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION_INFO = _LEAP_CONNECTION_INFO;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Retrieves status information about the specified connection."]
    #[doc = ""]
    #[doc = " Call LeapCreateConnection() to generate the handle for the connection;"]
    #[doc = " call LeapOpenConnection() to establish the connection; then call"]
    #[doc = " this function to check the connection status."]
    #[doc = ""]
    #[doc = " @param hConnection The handle of the connection of interest. Created by LeapCreateConnection."]
    #[doc = " @param[out] pInfo A pointer to a buffer that receives additional connection information. One input,"]
    #[doc = "   the size field of pInfo is the size of the buffer(i.e. the size of a LEAP_CONNECTION_INFO"]
    #[doc = "   struct); On output, the size field of pInfo receives the size necessary to hold"]
    #[doc = "   the entire information block."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapGetConnectionInfo(
        hConnection: LEAP_CONNECTION,
        pInfo: *mut LEAP_CONNECTION_INFO,
    ) -> eLeapRS;
}
#[doc = " The policy allowing an application to receive frames in the background. @since 3.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_BackgroundFrames: _eLeapPolicyFlag = 1;
#[doc = " The policy specifying whether to automatically stream images from the device. @since 4.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_Images: _eLeapPolicyFlag = 2;
#[doc = " The policy specifying whether to optimize tracking for head-mounted device. @since 3.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_OptimizeHMD: _eLeapPolicyFlag = 4;
#[doc = " The policy allowing an application to pause or resume service tracking. @since 3.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_AllowPauseResume: _eLeapPolicyFlag = 8;
#[doc = " The policy allowing an application to receive per-frame map points. @since 4.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_MapPoints: _eLeapPolicyFlag = 128;
#[doc = " The policy specifying whether to optimize tracking for screen-top device. @since 5.0.0"]
pub const _eLeapPolicyFlag_eLeapPolicyFlag_OptimizeScreenTop: _eLeapPolicyFlag = 256;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates flags for the service policies."]
pub type _eLeapPolicyFlag = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates flags for the service policies."]
pub use self::_eLeapPolicyFlag as eLeapPolicyFlag;
#[doc = " \\ingroup Structs"]
#[doc = " The response from a request to get or set a policy."]
#[doc = " LeapPollConnection() creates this struct when the response becomes available."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_POLICY_EVENT {
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub reserved: u32,
    #[doc = " A bitfield containing the policies effective at the"]
    #[doc = " time the policy event was processed. @since 3.0.0"]
    pub current_policy: u32,
}
#[test]
fn bindgen_test_layout__LEAP_POLICY_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_POLICY_EVENT>(),
        8usize,
        concat!("Size of: ", stringify!(_LEAP_POLICY_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_POLICY_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_POLICY_EVENT))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POLICY_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POLICY_EVENT),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_current_policy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POLICY_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_policy) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POLICY_EVENT),
                "::",
                stringify!(current_policy)
            )
        );
    }
    test_field_current_policy();
}
#[doc = " \\ingroup Structs"]
#[doc = " The response from a request to get or set a policy."]
#[doc = " LeapPollConnection() creates this struct when the response becomes available."]
#[doc = " @since 3.0.0"]
pub type LEAP_POLICY_EVENT = _LEAP_POLICY_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " The response from a request to get or set a policy."]
#[doc = " LeapPollConnection() creates this struct when the response becomes available."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_TRACKING_MODE_EVENT {
    #[doc = " Reserved for future use. @since 5.0.0"]
    pub reserved: u32,
    #[doc = " An enum specifying the tracking mode effective at the"]
    #[doc = " time the tracking mode event was processed. @since 5.0.0"]
    pub current_tracking_mode: eLeapTrackingMode,
}
#[test]
fn bindgen_test_layout__LEAP_TRACKING_MODE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_TRACKING_MODE_EVENT>(),
        8usize,
        concat!("Size of: ", stringify!(_LEAP_TRACKING_MODE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_TRACKING_MODE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_TRACKING_MODE_EVENT))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_MODE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_MODE_EVENT),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_current_tracking_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_MODE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_tracking_mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_MODE_EVENT),
                "::",
                stringify!(current_tracking_mode)
            )
        );
    }
    test_field_current_tracking_mode();
}
#[doc = " \\ingroup Structs"]
#[doc = " The response from a request to get or set a policy."]
#[doc = " LeapPollConnection() creates this struct when the response becomes available."]
#[doc = " @since 3.0.0"]
pub type LEAP_TRACKING_MODE_EVENT = _LEAP_TRACKING_MODE_EVENT;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Sets or clears one or more policy flags."]
    #[doc = ""]
    #[doc = " Changing policies is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_POLICY_EVENT containing the current"]
    #[doc = " policies, reflecting any changes."]
    #[doc = ""]
    #[doc = " To get the current policies without changes, specify zero for both the set"]
    #[doc = " and clear parameters. When ready, LeapPollConnection() provides a LEAP_POLICY_EVENT"]
    #[doc = " containing the current settings."]
    #[doc = ""]
    #[doc = " The eLeapPolicyFlag enumeration defines the policy flags."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param set A bitwise combination of flags to be set. Set to 0 if not setting any flags."]
    #[doc = " @param clear A bitwise combination of flags to be cleared. Set to 0 to if not clearing any flags."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapSetPolicyFlags(hConnection: LEAP_CONNECTION, set: u64, clear: u64) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Sets or clears one or more policy flags for a particular device."]
    #[doc = ""]
    #[doc = " Changing policies is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_POLICY_EVENT containing the current"]
    #[doc = " policies, reflecting any changes."]
    #[doc = ""]
    #[doc = " To get the current policies without changes, specify zero for both the set"]
    #[doc = " and clear parameters. When ready, LeapPollConnection() provides a LEAP_POLICY_EVENT"]
    #[doc = " containing the current settings."]
    #[doc = ""]
    #[doc = " The eLeapPolicyFlag enumeration defines the policy flags."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param set A bitwise combination of flags to be set. Set to 0 if not setting any flags."]
    #[doc = " @param clear A bitwise combination of flags to be cleared. Set to 0 if not clearing any flags."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapSetPolicyFlagsEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        set: u64,
        clear: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Requests a tracking mode."]
    #[doc = ""]
    #[doc = " Changing tracking modes is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_POLICY_EVENT containing the current"]
    #[doc = " policies, reflecting any changes."]
    #[doc = ""]
    #[doc = " The eLeapTrackingMode enumeration defines the tracking mode."]
    #[doc = "."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param mode The enum value specifying the requested tracking mode"]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.0.0"]
    pub fn LeapSetTrackingMode(hConnection: LEAP_CONNECTION, mode: eLeapTrackingMode) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Requests a tracking mode for a particular device."]
    #[doc = ""]
    #[doc = " Changing tracking modes is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_POLICY_EVENT containing the current"]
    #[doc = " policies, reflecting any changes."]
    #[doc = ""]
    #[doc = " The eLeapTrackingMode enumeration defines the tracking mode."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param mode The enum value specifying the requested tracking mode."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapSetTrackingModeEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        mode: eLeapTrackingMode,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Requests the currently set tracking mode."]
    #[doc = ""]
    #[doc = " Requesting the current tracking mode is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_TRACKING_MODE_EVENT containing the current"]
    #[doc = " tracking mode, reflecting any changes."]
    #[doc = ""]
    #[doc = " The eLeapTrackingMode enumeration defines the tracking mode."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.0.0"]
    pub fn LeapGetTrackingMode(hConnection: LEAP_CONNECTION) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Requests the currently set tracking mode for a particular device."]
    #[doc = ""]
    #[doc = " Requesting the current tracking mode is asynchronous. After you call this function, a subsequent"]
    #[doc = " call to LeapPollConnection provides a LEAP_TRACKING_MODE_EVENT containing the current"]
    #[doc = " tracking mode, reflecting any changes."]
    #[doc = ""]
    #[doc = " The eLeapTrackingMode enumeration defines the tracking mode."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapGetTrackingModeEx(hConnection: LEAP_CONNECTION, hDevice: LEAP_DEVICE) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Pauses the service"]
    #[doc = ""]
    #[doc = " Attempts to pause or unpause the service depending on the argument."]
    #[doc = " This is treated as a 'user pause', as though a user had requested a pause through the"]
    #[doc = " Leap Control Panel. The connection must have the AllowPauseResume policy set"]
    #[doc = " or it will fail with eLeapRS_InvalidArgument."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param pause Set to 'true' to pause, or 'false' to unpause."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 4.0.0"]
    pub fn LeapSetPause(hConnection: LEAP_CONNECTION, pause: bool) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Sets the allocator functions to use for a particular connection."]
    #[doc = ""]
    #[doc = " If user-supplied allocator functions are not supplied, the functions that require"]
    #[doc = " dynamic memory allocation will not be available."]
    #[doc = ""]
    #[doc = " @param hConnection A handle to the connection object, created by LeapCreateConnection()."]
    #[doc = " @param allocator A pointer to a structure containing the allocator functions to be called"]
    #[doc = " as needed by the library."]
    #[doc = " @since 4.0.0"]
    pub fn LeapSetAllocator(
        hConnection: LEAP_CONNECTION,
        allocator: *const LEAP_ALLOCATOR,
    ) -> eLeapRS;
}
#[doc = " The type is unknown (which is an abnormal condition). @since 3.0.0"]
pub const _eLeapValueType_eLeapValueType_Unknown: _eLeapValueType = 0;
#[doc = " A boolean value. @since 3.0.0"]
pub const _eLeapValueType_eLeapValueType_Boolean: _eLeapValueType = 1;
#[doc = " An integer value. @since 3.0.0"]
pub const _eLeapValueType_eLeapValueType_Int32: _eLeapValueType = 2;
#[doc = " A floating point value. @since 3.0.0"]
pub const _eLeapValueType_eLeapValueType_Float: _eLeapValueType = 3;
#[doc = " A string value. @since 3.0.0"]
pub const _eLeapValueType_eLeapValueType_String: _eLeapValueType = 4;
#[doc = " A string value. @since 3.0.0"]
pub const _eLeapValueType_FORCE_DWORD: _eLeapValueType = 2147483647;
#[doc = "  \\ingroup Enum"]
#[doc = " Identifies the operative data type of a LEAP_VARIANT struct instance."]
#[doc = " @since 3.0.0"]
pub type _eLeapValueType = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Identifies the operative data type of a LEAP_VARIANT struct instance."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapValueType as eLeapValueType;
#[doc = " \\ingroup Structs"]
#[doc = " A variant data type used to get and set service configuration values."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_VARIANT {
    #[doc = " The active data type in this instance. @since 3.0.0"]
    pub type_: eLeapValueType,
    pub __bindgen_anon_1: _LEAP_VARIANT__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _LEAP_VARIANT__bindgen_ty_1 {
    #[doc = " A Boolean value. @since 3.0.0"]
    pub boolValue: bool,
    #[doc = " An integer value. @since 3.0.0"]
    pub iValue: i32,
    #[doc = " A floating point value. @since 3.0.0"]
    pub fValue: f32,
    #[doc = " A pointer to a string buffer. @since 3.0.0"]
    pub strValue: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__LEAP_VARIANT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VARIANT__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LEAP_VARIANT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VARIANT__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_VARIANT__bindgen_ty_1))
    );
    fn test_field_boolValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VARIANT__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).boolValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VARIANT__bindgen_ty_1),
                "::",
                stringify!(boolValue)
            )
        );
    }
    test_field_boolValue();
    fn test_field_iValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VARIANT__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VARIANT__bindgen_ty_1),
                "::",
                stringify!(iValue)
            )
        );
    }
    test_field_iValue();
    fn test_field_fValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VARIANT__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VARIANT__bindgen_ty_1),
                "::",
                stringify!(fValue)
            )
        );
    }
    test_field_fValue();
    fn test_field_strValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VARIANT__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VARIANT__bindgen_ty_1),
                "::",
                stringify!(strValue)
            )
        );
    }
    test_field_strValue();
}
#[test]
fn bindgen_test_layout__LEAP_VARIANT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VARIANT>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_VARIANT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VARIANT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_VARIANT))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VARIANT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VARIANT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
#[doc = " \\ingroup Structs"]
#[doc = " A variant data type used to get and set service configuration values."]
#[doc = " @since 3.0.0"]
pub type LEAP_VARIANT = _LEAP_VARIANT;
#[doc = " \\ingroup Structs"]
#[doc = " Contains the response to a configuration value request."]
#[doc = " Call LeapRequestConfigValue() to request a service config value. The value is"]
#[doc = " fetched asynchronously since it requires a service transaction. LeapPollConnection()"]
#[doc = " returns this event structure when the request has been processed. Use the requestID"]
#[doc = " value to correlate the response to the originating request."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_CONFIG_RESPONSE_EVENT {
    #[doc = " An identifier for correlating the request and response. @since 3.0.0"]
    pub requestID: u32,
    #[doc = " The configuration value retrieved from the service. Do not free any memory pointed to by"]
    #[doc = " this member. The value held is only valid until the next call to LeapPollConnection()."]
    #[doc = " @since 3.0.0"]
    pub value: LEAP_VARIANT,
}
#[test]
fn bindgen_test_layout__LEAP_CONFIG_RESPONSE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONFIG_RESPONSE_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(_LEAP_CONFIG_RESPONSE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONFIG_RESPONSE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONFIG_RESPONSE_EVENT))
    );
    fn test_field_requestID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONFIG_RESPONSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requestID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONFIG_RESPONSE_EVENT),
                "::",
                stringify!(requestID)
            )
        );
    }
    test_field_requestID();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONFIG_RESPONSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONFIG_RESPONSE_EVENT),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[doc = " \\ingroup Structs"]
#[doc = " Contains the response to a configuration value request."]
#[doc = " Call LeapRequestConfigValue() to request a service config value. The value is"]
#[doc = " fetched asynchronously since it requires a service transaction. LeapPollConnection()"]
#[doc = " returns this event structure when the request has been processed. Use the requestID"]
#[doc = " value to correlate the response to the originating request."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONFIG_RESPONSE_EVENT = _LEAP_CONFIG_RESPONSE_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " The result of a configuration change request. Contains a status of true for a"]
#[doc = " successful change."]
#[doc = " Call LeapSaveConfigValue() to request a service config change. The change is"]
#[doc = " performed asynchronously -- and may fail. LeapPollConnection()"]
#[doc = " returns this event structure when the request has been processed. Use the requestID"]
#[doc = " value to correlate the response to the originating request."]
#[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CONFIG_CHANGE_EVENT {
    #[doc = " An identifier for correlating the request and response. @since 3.0.0"]
    pub requestID: u32,
    #[doc = " The result of the change operation: true on success; false on failure. @since 3.0.0"]
    pub status: bool,
}
#[test]
fn bindgen_test_layout__LEAP_CONFIG_CHANGE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONFIG_CHANGE_EVENT>(),
        5usize,
        concat!("Size of: ", stringify!(_LEAP_CONFIG_CHANGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONFIG_CHANGE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONFIG_CHANGE_EVENT))
    );
    fn test_field_requestID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONFIG_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requestID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONFIG_CHANGE_EVENT),
                "::",
                stringify!(requestID)
            )
        );
    }
    test_field_requestID();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONFIG_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONFIG_CHANGE_EVENT),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[doc = " \\ingroup Structs"]
#[doc = " The result of a configuration change request. Contains a status of true for a"]
#[doc = " successful change."]
#[doc = " Call LeapSaveConfigValue() to request a service config change. The change is"]
#[doc = " performed asynchronously -- and may fail. LeapPollConnection()"]
#[doc = " returns this event structure when the request has been processed. Use the requestID"]
#[doc = " value to correlate the response to the originating request."]
#[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONFIG_CHANGE_EVENT = _LEAP_CONFIG_CHANGE_EVENT;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Causes the client to commit a configuration change to the Ultraleap Tracking Service."]
    #[doc = ""]
    #[doc = " The change is performed asynchronously -- and may fail. LeapPollConnection()"]
    #[doc = " returns this event structure when the request has been processed. Use the pRequestID"]
    #[doc = " value to correlate the response to the originating request."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param key The key of the configuration to commit."]
    #[doc = " @param value The value of the configuration to commit."]
    #[doc = " @param[out] pRequestID A pointer to a memory location to which the id for this request is written, or nullptr if this value is not needed."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapSaveConfigValue(
        hConnection: LEAP_CONNECTION,
        key: *const ::std::os::raw::c_char,
        value: *const LEAP_VARIANT,
        pRequestID: *mut u32,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Requests the current value of a service configuration setting."]
    #[doc = " The value is fetched asynchronously since it requires a service transaction. LeapPollConnection()"]
    #[doc = " returns this event structure when the request has been processed. Use the pRequestID"]
    #[doc = " value to correlate the response to the originating request."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param key The key of the configuration to request"]
    #[doc = " @param[out] pRequestID A pointer to a memory location to which the id for this request is written."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapRequestConfigValue(
        hConnection: LEAP_CONNECTION,
        key: *const ::std::os::raw::c_char,
        pRequestID: *mut u32,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Retrieves a list of Ultraleap Tracking camera devices currently attached to the system."]
    #[doc = ""]
    #[doc = " To get the number of connected devices, call this function with the pArray parameter"]
    #[doc = " set to null. The number of devices is written to the memory specified by pnArray."]
    #[doc = " Use the device count to create an array of LEAP_DEVICE_REF structs large enough to"]
    #[doc = " hold the number of connected devices. Finally, call LeapGetDeviceList() with this"]
    #[doc = " array and known count to get the list of Leap devices. A device must be opened with"]
    #[doc = " LeapOpenDevice() before device properties can be queried."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param[out] pArray A pointer to an array that LeapC fills with the device list."]
    #[doc = " @param[in,out] pnArray On input, set to the number of elements in pArray; on output,"]
    #[doc = " LeapC sets this to the number of valid device handles."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapGetDeviceList(
        hConnection: LEAP_CONNECTION,
        pArray: *mut LEAP_DEVICE_REF,
        pnArray: *mut u32,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Opens a device reference and retrieves a handle to the device."]
    #[doc = ""]
    #[doc = " To ensure resources are properly freed, users must call LeapCloseDevice()"]
    #[doc = " when finished with the device, even if the retrieved device has problems"]
    #[doc = " or cannot stream."]
    #[doc = ""]
    #[doc = " @param rDevice A device reference."]
    #[doc = " @param[out] phDevice A pointer that receives the opened device handle."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapOpenDevice(rDevice: LEAP_DEVICE_REF, phDevice: *mut LEAP_DEVICE) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " For a multi-device aware client, sets the device to use in the context of"]
    #[doc = " non-\"Ex\" API functions which are logically device-specific but don't provide"]
    #[doc = " a device parameter."]
    #[doc = ""]
    #[doc = " Automatically subscribes to the specified device (see LeapSubscribeEvents()),"]
    #[doc = " and if \\p unsubscribeOthers is \\c true, then unsubscribes from all other devices"]
    #[doc = " as well (see LeapUnsubscribeEvents())."]
    #[doc = ""]
    #[doc = " Affects future invocations of the following functions:"]
    #[doc = "  - LeapCameraMatrix()"]
    #[doc = "  - LeapDistortionCoeffs()"]
    #[doc = "  - LeapGetFrameSize()"]
    #[doc = "  - LeapInterpolateFrame()"]
    #[doc = "  - LeapInterpolateFrameFromTime()"]
    #[doc = "  - LeapPixelToRectilinear()"]
    #[doc = "  - LeapRectilinearToPixel()"]
    #[doc = ""]
    #[doc = " It is not necessary to call this function from a client that does not claim"]
    #[doc = " to be multi-device-aware (see ::eLeapConnectionConfig and"]
    #[doc = " ::LeapCreateConnection)."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param unsubscribeOthers If \\c true, unsubscribe from all other devices."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapSetPrimaryDevice(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        unsubscribeOthers: bool,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Subscribe to event messages based on device."]
    #[doc = ""]
    #[doc = " If events from multiple devices are being sent from a service, this function"]
    #[doc = " allows the client to receive events from the specified device. Clients that"]
    #[doc = " claim to be multi-device-aware (see ::eLeapConnectionConfig and"]
    #[doc = " ::LeapCreateConnection) must subscribe to a device to receive various"]
    #[doc = " device-specific events."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A handle to the device for which events are desired."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapSubscribeEvents(hConnection: LEAP_CONNECTION, hDevice: LEAP_DEVICE) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Unsubscribe from event messages based on device."]
    #[doc = ""]
    #[doc = " If events from multiple devices are being sent from a service, this function"]
    #[doc = " prevents receiving further events from the specified device that had"]
    #[doc = " previously been enabled using a call to LeapSubscribeEvents()."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A handle to the device for which events are desired."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapUnsubscribeEvents(hConnection: LEAP_CONNECTION, hDevice: LEAP_DEVICE) -> eLeapRS;
}
#[doc = " The device can send color images. @since 3.0.0"]
pub const eLeapDeviceCaps_eLeapDeviceCaps_Color: eLeapDeviceCaps = 1;
#[doc = "  \\ingroup Enum"]
#[doc = " Flags enumerating Leap device capabilities. @since 3.0.0"]
pub type eLeapDeviceCaps = ::std::os::raw::c_int;
#[doc = " An unknown device that is compatible with the tracking software. @since 3.1.3"]
pub const _eLeapDevicePID_eLeapDevicePID_Unknown: _eLeapDevicePID = 0;
#[doc = " The Leap Motion Controller (the first consumer peripheral). @since 3.0.0"]
pub const _eLeapDevicePID_eLeapDevicePID_Peripheral: _eLeapDevicePID = 3;
#[doc = " Internal research product codename \"Dragonfly\". @since 3.0.0"]
pub const _eLeapDevicePID_eLeapDevicePID_Dragonfly: _eLeapDevicePID = 4354;
#[doc = " Internal research product codename \"Nightcrawler\". @since 3.0.0"]
pub const _eLeapDevicePID_eLeapDevicePID_Nightcrawler: _eLeapDevicePID = 4609;
#[doc = " Research product codename \"Rigel\". @since 4.0.0"]
pub const _eLeapDevicePID_eLeapDevicePID_Rigel: _eLeapDevicePID = 4610;
#[doc = " The Ultraleap Stereo IR 170 (SIR170) hand tracking module. @since 5.3.0"]
pub const _eLeapDevicePID_eLeapDevicePID_SIR170: _eLeapDevicePID = 4611;
#[doc = " The Ultraleap 3Di hand tracking camera. @since 5.3.0"]
pub const _eLeapDevicePID_eLeapDevicePID_3Di: _eLeapDevicePID = 4612;
#[doc = " An invalid device type. Not currently in use. @since 3.1.3"]
pub const _eLeapDevicePID_eLeapDevicePID_Invalid: _eLeapDevicePID = -1;
#[doc = " \\ingroup Enum"]
#[doc = " Device hardware types. @since 3.0.0"]
pub type _eLeapDevicePID = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Device hardware types. @since 3.0.0"]
pub use self::_eLeapDevicePID as eLeapDevicePID;
#[doc = " \\ingroup Structs"]
#[doc = " Properties of a Leap device."]
#[doc = " Get a LEAP_DEVICE_INFO by calling LeapGetDeviceInfo() with the handle for"]
#[doc = " device. The device must be open."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE_INFO {
    #[doc = " Size of this structure. @since 3.0.0"]
    pub size: u32,
    #[doc = " A combination of eLeapDeviceStatus flags. @since 3.0.0"]
    pub status: u32,
    #[doc = " A combination of eLeapDeviceCaps flags. @since 3.0.0"]
    pub caps: u32,
    #[doc = " One of the eLeapDevicePID members. @since 3.0.0"]
    pub pid: eLeapDevicePID,
    #[doc = " The device baseline, in micrometers."]
    #[doc = ""]
    #[doc = " The baseline is defined as the distance between the center axis of each lens in a stereo camera"]
    #[doc = " system. For other camera systems, this value is set to zero."]
    #[doc = " @since 3.0.0"]
    pub baseline: u32,
    #[doc = " The required length of the serial number char buffer including the null character. @since 3.0.0"]
    pub serial_length: u32,
    #[doc = " A pointer to the null-terminated device serial number string. @since 3.0.0"]
    pub serial: *mut ::std::os::raw::c_char,
    #[doc = " The horizontal field of view of this device in radians. @since 3.0.0"]
    pub h_fov: f32,
    #[doc = " The vertical field of view of this device in radians. @since 3.0.0"]
    pub v_fov: f32,
    #[doc = " The maximum range for this device, in micrometers. @since 3.0.0"]
    pub range: u32,
}
#[test]
fn bindgen_test_layout__LEAP_DEVICE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DEVICE_INFO>(),
        44usize,
        concat!("Size of: ", stringify!(_LEAP_DEVICE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DEVICE_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DEVICE_INFO))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_caps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(caps)
            )
        );
    }
    test_field_caps();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
    fn test_field_baseline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(baseline)
            )
        );
    }
    test_field_baseline();
    fn test_field_serial_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serial_length) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(serial_length)
            )
        );
    }
    test_field_serial_length();
    fn test_field_serial() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(serial)
            )
        );
    }
    test_field_serial();
    fn test_field_h_fov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_fov) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(h_fov)
            )
        );
    }
    test_field_h_fov();
    fn test_field_v_fov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v_fov) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(v_fov)
            )
        );
    }
    test_field_v_fov();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_INFO),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
}
#[doc = " \\ingroup Structs"]
#[doc = " Properties of a Leap device."]
#[doc = " Get a LEAP_DEVICE_INFO by calling LeapGetDeviceInfo() with the handle for"]
#[doc = " device. The device must be open."]
#[doc = " @since 3.0.0"]
pub type LEAP_DEVICE_INFO = _LEAP_DEVICE_INFO;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Gets device properties."]
    #[doc = ""]
    #[doc = " To get the device serial number, you must supply a LEAP_DEVICE_INFO struct whose"]
    #[doc = " serial member points to a char array large enough to hold the null-terminated"]
    #[doc = " serial number string. To get the required length, call LeapGetDeviceInfo() using"]
    #[doc = " a LEAP_DEVICE_INFO struct that has serial set to NULL. LeapC sets serial_length field of"]
    #[doc = " the struct to the required length. You can then allocate memory for the string,"]
    #[doc = " set the serial field, and call this function again."]
    #[doc = ""]
    #[doc = " @param hDevice A handle to the device to be queried."]
    #[doc = " @param[out] info The struct to receive the device property data."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.0.0"]
    pub fn LeapGetDeviceInfo(hDevice: LEAP_DEVICE, info: *mut LEAP_DEVICE_INFO) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Get the transform to world coordinates from 3D Leap coordinates."]
    #[doc = ""]
    #[doc = " To get the transform, you must supply an array of 16 elements."]
    #[doc = ""]
    #[doc = " The function will return a an array representing a 4 x 4 matrix of the form:"]
    #[doc = ""]
    #[doc = " R, t"]
    #[doc = " 0, 1"]
    #[doc = ""]
    #[doc = " where:"]
    #[doc = " R is a 3 x 3 rotation matrix"]
    #[doc = " t is a 3 x 1 translation vector"]
    #[doc = ""]
    #[doc = " Note that the matrix is in column major, e.g. transform[12] corresponds to the x coordinate of the"]
    #[doc = " translation vector t."]
    #[doc = ""]
    #[doc = " A possible pipeline would be, for example:"]
    #[doc = " 1) Get \"palm_pos\" the position of the center of the palm (as a 3x1 vector)"]
    #[doc = " 2) Construct a 4x1 vector using the palm_position: palm_pos_4 = (palm_pos.x; palm_pos.y; palm_pos.z; 1.0f)"]
    #[doc = " 3) Create a 4x4 matrix \"trans_mat\" as illustrated above using the returned transform"]
    #[doc = " 4) Get the position of the center of the palm in world coordinates by multiplying trans_mat and palm_pos_4:"]
    #[doc = "    center_world_4 = trans_mat * palm_pos_4"]
    #[doc = ""]
    #[doc = " This function returns eLeapRS_Unsupported in the case where this functionality is not yet supported."]
    #[doc = ""]
    #[doc = " @param hDevice A handle to the device to be queried."]
    #[doc = " @param[out] transform A pointer to a single-precision float array of size 16, containing"]
    #[doc = "  the coefficients of the 4x4 matrix in Column Major order."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapGetDeviceTransform(hDevice: LEAP_DEVICE, transform: *mut f32) -> eLeapRS;
}
#[doc = " \\ingroup Structs"]
#[doc = " Device event information."]
#[doc = ""]
#[doc = " LeapPollConnection() produces a message containing this event when a new"]
#[doc = " device is detected. You can use the handle provided by the device filed to"]
#[doc = " open a device so that you can access its properties."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE_EVENT {
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub flags: u32,
    #[doc = " The handle reference of to the newly attached device. @since 3.0.0"]
    pub device: LEAP_DEVICE_REF,
    #[doc = " The status of the connected device. A combination of flags from the eLeapDeviceStatus collection."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout__LEAP_DEVICE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DEVICE_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(_LEAP_DEVICE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DEVICE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DEVICE_EVENT))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_EVENT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_device() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_EVENT),
                "::",
                stringify!(device)
            )
        );
    }
    test_field_device();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_EVENT),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[doc = " \\ingroup Structs"]
#[doc = " Device event information."]
#[doc = ""]
#[doc = " LeapPollConnection() produces a message containing this event when a new"]
#[doc = " device is detected. You can use the handle provided by the device filed to"]
#[doc = " open a device so that you can access its properties."]
#[doc = " @since 3.0.0"]
pub type LEAP_DEVICE_EVENT = _LEAP_DEVICE_EVENT;
#[doc = " The device is sending out frames. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_Streaming: _eLeapDeviceStatus = 1;
#[doc = " Device streaming has been paused. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_Paused: _eLeapDeviceStatus = 2;
#[doc = " There are known sources of infrared interference. Device has transitioned to"]
#[doc = " robust mode in order to compensate.  @since 3.1.3"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_Robust: _eLeapDeviceStatus = 4;
#[doc = " The device's window is smudged, tracking may be degraded.  @since 3.1.3"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_Smudged: _eLeapDeviceStatus = 8;
#[doc = " The device has entered low-resource mode. @since 4.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_LowResource: _eLeapDeviceStatus = 16;
#[doc = " The device has failed, but the failure reason is not known. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_UnknownFailure: _eLeapDeviceStatus = -402587648;
#[doc = " The device has a bad calibration record and cannot send frames. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_BadCalibration: _eLeapDeviceStatus = -402587647;
#[doc = " The device reports corrupt firmware or cannot install a required firmware update. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_BadFirmware: _eLeapDeviceStatus = -402587646;
#[doc = " The device USB connection is faulty. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_BadTransport: _eLeapDeviceStatus = -402587645;
#[doc = " The device USB control interfaces failed to initialize. @since 3.0.0"]
pub const _eLeapDeviceStatus_eLeapDeviceStatus_BadControl: _eLeapDeviceStatus = -402587644;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates the device status codes."]
#[doc = " @since 3.0.0"]
pub type _eLeapDeviceStatus = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Enumerates the device status codes."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapDeviceStatus as eLeapDeviceStatus;
#[doc = " \\ingroup Structs"]
#[doc = " Device failure information."]
#[doc = " LeapPollConnection() produces a message containing this event when a"]
#[doc = " device fails. Only partial information may be available. If hDevice is"]
#[doc = " non-null, then you can use it to identify the failed device with a known,"]
#[doc = " open device."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE_FAILURE_EVENT {
    #[doc = " The status of this failure event. @since 3.0.0"]
    pub status: eLeapDeviceStatus,
    #[doc = " A handle to the device generating this failure event, if available, otherwise NULL."]
    #[doc = ""]
    #[doc = " You are not responsible for closing this handle."]
    #[doc = " @since 3.0.0"]
    pub hDevice: LEAP_DEVICE,
}
#[test]
fn bindgen_test_layout__LEAP_DEVICE_FAILURE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DEVICE_FAILURE_EVENT>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_DEVICE_FAILURE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DEVICE_FAILURE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DEVICE_FAILURE_EVENT))
    );
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_FAILURE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_FAILURE_EVENT),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_hDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_FAILURE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hDevice) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_FAILURE_EVENT),
                "::",
                stringify!(hDevice)
            )
        );
    }
    test_field_hDevice();
}
#[doc = " \\ingroup Structs"]
#[doc = " Device failure information."]
#[doc = " LeapPollConnection() produces a message containing this event when a"]
#[doc = " device fails. Only partial information may be available. If hDevice is"]
#[doc = " non-null, then you can use it to identify the failed device with a known,"]
#[doc = " open device."]
#[doc = " @since 3.0.0"]
pub type LEAP_DEVICE_FAILURE_EVENT = _LEAP_DEVICE_FAILURE_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " Identifying information for a frame of tracking data. @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_FRAME_HEADER {
    #[doc = " Reserved, set to zero. @since 3.0.0"]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = " A unique identifier for this frame"]
    #[doc = ""]
    #[doc = " All frames carrying this frame ID are part of the same unit of processing. This counter"]
    #[doc = " is generally an increasing counter, but may reset to another value if the user stops and"]
    #[doc = " restarts streaming."]
    #[doc = ""]
    #[doc = " For interpolated frames, this value corresponds to the identifier of the frame upper bound."]
    #[doc = " @since 3.0.0"]
    pub frame_id: i64,
    #[doc = " The timestamp for this image, in microseconds, referenced against LeapGetNow()."]
    #[doc = " @since 3.0.0"]
    pub timestamp: i64,
}
#[test]
fn bindgen_test_layout__LEAP_FRAME_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_FRAME_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_LEAP_FRAME_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_FRAME_HEADER>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_FRAME_HEADER))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_FRAME_HEADER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_FRAME_HEADER),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_FRAME_HEADER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_FRAME_HEADER),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_FRAME_HEADER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_FRAME_HEADER),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
}
#[doc = " \\ingroup Structs"]
#[doc = " Identifying information for a frame of tracking data. @since 3.0.0"]
pub type LEAP_FRAME_HEADER = _LEAP_FRAME_HEADER;
#[doc = " An invalid or unknown type. @since 3.0.0"]
pub const _eLeapImageType_eLeapImageType_UNKNOWN: _eLeapImageType = 0;
#[doc = " Default, processed IR images. @since 3.0.0"]
pub const _eLeapImageType_eLeapImageType_Default: _eLeapImageType = 1;
#[doc = " Raw images from the device. @since 3.0.0"]
pub const _eLeapImageType_eLeapImageType_Raw: _eLeapImageType = 2;
#[doc = " \\ingroup Enum"]
#[doc = " Functional image types (not data formats)."]
pub type _eLeapImageType = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Functional image types (not data formats)."]
pub use self::_eLeapImageType as eLeapImageType;
#[doc = " An invalid or unknown format. @since 3.0.0"]
pub const _eLeapImageFormat_eLeapImageFormat_UNKNOWN: _eLeapImageFormat = 0;
#[doc = " An infrared image. @since 3.0.0"]
pub const _eLeapImageFormat_eLeapImageFormat_IR: _eLeapImageFormat = 3240521;
#[doc = " A Bayer RGBIr image with uncorrected RGB channels. @since 3.0.0"]
pub const _eLeapImageFormat_eLeapImageFormat_RGBIr_Bayer: _eLeapImageFormat = 1229083207;
#[doc = "  \\ingroup Enum"]
#[doc = " Image formats."]
#[doc = " @since 3.0.0"]
pub type _eLeapImageFormat = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Image formats."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapImageFormat as eLeapImageFormat;
#[doc = " An unknown or invalid type. @since 3.0.0"]
pub const _eLeapPerspectiveType_eLeapPerspectiveType_invalid: _eLeapPerspectiveType = 0;
#[doc = " A canonically left image. @since 3.0.0"]
pub const _eLeapPerspectiveType_eLeapPerspectiveType_stereo_left: _eLeapPerspectiveType = 1;
#[doc = " A canonically right image. @since 3.0.0"]
pub const _eLeapPerspectiveType_eLeapPerspectiveType_stereo_right: _eLeapPerspectiveType = 2;
#[doc = " Reserved for future use. @since 3.0.0"]
pub const _eLeapPerspectiveType_eLeapPerspectiveType_mono: _eLeapPerspectiveType = 3;
#[doc = "  \\ingroup Enum"]
#[doc = " Camera perspective types."]
#[doc = " @since 3.0.0"]
pub type _eLeapPerspectiveType = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Camera perspective types."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapPerspectiveType as eLeapPerspectiveType;
#[doc = " Infrared calibration (default). @since 4.1.0"]
pub const _eLeapCameraCalibrationType_eLeapCameraCalibrationType_infrared:
    _eLeapCameraCalibrationType = 0;
#[doc = " Visual calibration. @since 4.1.0"]
pub const _eLeapCameraCalibrationType_eLeapCameraCalibrationType_visual:
    _eLeapCameraCalibrationType = 1;
#[doc = "  \\ingroup Enum"]
#[doc = " Camera calibration types."]
#[doc = " @since 3.0.0"]
pub type _eLeapCameraCalibrationType = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " Camera calibration types."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapCameraCalibrationType as eLeapCameraCalibrationType;
#[doc = " \\ingroup Structs"]
#[doc = " Properties of a sensor image."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_IMAGE_PROPERTIES {
    #[doc = " The type of this image. @since 3.0.0"]
    pub type_: eLeapImageType,
    #[doc = " The format of this image. @since 3.0.0"]
    pub format: eLeapImageFormat,
    #[doc = " The number of bytes per image pixel. @since 3.0.0"]
    pub bpp: u32,
    #[doc = " The number of horizontal pixels in the image. @since 3.0.0"]
    pub width: u32,
    #[doc = " The number of rows of pixels in the image. @since 3.0.0"]
    pub height: u32,
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub x_scale: f32,
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub y_scale: f32,
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub x_offset: f32,
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub y_offset: f32,
}
#[test]
fn bindgen_test_layout__LEAP_IMAGE_PROPERTIES() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_IMAGE_PROPERTIES>(),
        36usize,
        concat!("Size of: ", stringify!(_LEAP_IMAGE_PROPERTIES))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_IMAGE_PROPERTIES>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_IMAGE_PROPERTIES))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_bpp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(bpp)
            )
        );
    }
    test_field_bpp();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_x_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_scale) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(x_scale)
            )
        );
    }
    test_field_x_scale();
    fn test_field_y_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_scale) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(y_scale)
            )
        );
    }
    test_field_y_scale();
    fn test_field_x_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(x_offset)
            )
        );
    }
    test_field_x_offset();
    fn test_field_y_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_PROPERTIES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_PROPERTIES),
                "::",
                stringify!(y_offset)
            )
        );
    }
    test_field_y_offset();
}
#[doc = " \\ingroup Structs"]
#[doc = " Properties of a sensor image."]
#[doc = " @since 3.0.0"]
pub type LEAP_IMAGE_PROPERTIES = _LEAP_IMAGE_PROPERTIES;
#[doc = " \\ingroup Structs"]
#[doc = " A matrix containing lens distortion correction coordinates."]
#[doc = ""]
#[doc = " Each point in the grid contains the coordinates of the pixel in the image buffer that"]
#[doc = " contains the data for the pixel in the undistorted image corresponding"]
#[doc = " to that point in the grid."]
#[doc = " Interpolate between points in the matrix to correct image pixels that don't"]
#[doc = " fall directly underneath a point in the distortion grid."]
#[doc = ""]
#[doc = " Current devices use a 64x64 point distortion grid."]
#[doc = " @since 3.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DISTORTION_MATRIX {
    #[doc = " A grid of 2D points. @since 3.0.0"]
    pub matrix: [[_LEAP_DISTORTION_MATRIX__bindgen_ty_1; 64usize]; 64usize],
}
#[doc = " A point in the distortion grid. @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DISTORTION_MATRIX__bindgen_ty_1 {
    #[doc = " The x-pixel coordinate. @since 3.0.0"]
    pub x: f32,
    #[doc = " The y-pixel coordinate. @since 3.0.0"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout__LEAP_DISTORTION_MATRIX__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DISTORTION_MATRIX__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_DISTORTION_MATRIX__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DISTORTION_MATRIX__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_DISTORTION_MATRIX__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DISTORTION_MATRIX__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DISTORTION_MATRIX__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DISTORTION_MATRIX__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DISTORTION_MATRIX__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[test]
fn bindgen_test_layout__LEAP_DISTORTION_MATRIX() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DISTORTION_MATRIX>(),
        32768usize,
        concat!("Size of: ", stringify!(_LEAP_DISTORTION_MATRIX))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DISTORTION_MATRIX>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DISTORTION_MATRIX))
    );
    fn test_field_matrix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DISTORTION_MATRIX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DISTORTION_MATRIX),
                "::",
                stringify!(matrix)
            )
        );
    }
    test_field_matrix();
}
#[doc = " \\ingroup Structs"]
#[doc = " A matrix containing lens distortion correction coordinates."]
#[doc = ""]
#[doc = " Each point in the grid contains the coordinates of the pixel in the image buffer that"]
#[doc = " contains the data for the pixel in the undistorted image corresponding"]
#[doc = " to that point in the grid."]
#[doc = " Interpolate between points in the matrix to correct image pixels that don't"]
#[doc = " fall directly underneath a point in the distortion grid."]
#[doc = ""]
#[doc = " Current devices use a 64x64 point distortion grid."]
#[doc = " @since 3.0.0"]
pub type LEAP_DISTORTION_MATRIX = _LEAP_DISTORTION_MATRIX;
#[doc = " \\ingroup Structs"]
#[doc = " Describes the image to request."]
#[doc = " Pass this struct to the LeapImageRequest() function."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_IMAGE_FRAME_DESCRIPTION {
    #[doc = " The ID of the frame corresponding to the desired image. @since 3.0.0"]
    pub frame_id: i64,
    #[doc = " The type of the desired image. @since 3.0.0"]
    pub type_: eLeapImageType,
    #[doc = " Length of your image buffer. The buffer must be large enough to"]
    #[doc = " hold the request image."]
    pub buffer_len: u64,
    #[doc = " An allocated buffer large enough to contain the requested image. The buffer"]
    #[doc = " must remain valid until the image request completes or fails."]
    #[doc = " @since 3.0.0"]
    pub pBuffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__LEAP_IMAGE_FRAME_DESCRIPTION() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_IMAGE_FRAME_DESCRIPTION>(),
        28usize,
        concat!("Size of: ", stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_IMAGE_FRAME_DESCRIPTION>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION))
    );
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_FRAME_DESCRIPTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_FRAME_DESCRIPTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_buffer_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_FRAME_DESCRIPTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_len) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION),
                "::",
                stringify!(buffer_len)
            )
        );
    }
    test_field_buffer_len();
    fn test_field_pBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_FRAME_DESCRIPTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBuffer) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_FRAME_DESCRIPTION),
                "::",
                stringify!(pBuffer)
            )
        );
    }
    test_field_pBuffer();
}
#[doc = " \\ingroup Structs"]
#[doc = " Describes the image to request."]
#[doc = " Pass this struct to the LeapImageRequest() function."]
#[doc = " @since 3.0.0"]
pub type LEAP_IMAGE_FRAME_DESCRIPTION = _LEAP_IMAGE_FRAME_DESCRIPTION;
#[doc = " \\ingroup Structs"]
#[doc = " A three element, floating-point vector."]
#[doc = " @since 3.0.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LEAP_VECTOR {
    pub __bindgen_anon_1: _LEAP_VECTOR__bindgen_ty_1,
}
#[doc = " You can access the vector members as either an array or individual float values."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _LEAP_VECTOR__bindgen_ty_1 {
    #[doc = " The vector as an array. @since 3.0.0"]
    pub v: [f32; 3usize],
    pub __bindgen_anon_1: _LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The x spatial coordinate. @since 3.0.0"]
    pub x: f32,
    #[doc = " The y spatial coordinate. @since 3.0.0"]
    pub y: f32,
    #[doc = " The z spatial coordinate. @since 3.0.0"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout__LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VECTOR__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[test]
fn bindgen_test_layout__LEAP_VECTOR__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VECTOR__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_VECTOR__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VECTOR__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_VECTOR__bindgen_ty_1))
    );
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VECTOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VECTOR__bindgen_ty_1),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
}
#[test]
fn bindgen_test_layout__LEAP_VECTOR() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VECTOR>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_VECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VECTOR>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_VECTOR))
    );
}
#[doc = " \\ingroup Structs"]
#[doc = " A three element, floating-point vector."]
#[doc = " @since 3.0.0"]
pub type LEAP_VECTOR = _LEAP_VECTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LEAP_MATRIX_3x3 {
    pub m: [LEAP_VECTOR; 3usize],
}
#[test]
fn bindgen_test_layout__LEAP_MATRIX_3x3() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_MATRIX_3x3>(),
        36usize,
        concat!("Size of: ", stringify!(_LEAP_MATRIX_3x3))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_MATRIX_3x3>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_MATRIX_3x3))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_MATRIX_3x3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_MATRIX_3x3),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
pub type LEAP_MATRIX_3x3 = _LEAP_MATRIX_3x3;
#[doc = " \\ingroup Structs"]
#[doc = " A four element, floating point quaternion. @since 3.1.2"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LEAP_QUATERNION {
    pub __bindgen_anon_1: _LEAP_QUATERNION__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _LEAP_QUATERNION__bindgen_ty_1 {
    #[doc = " The quaternion as an array. @since 3.1.3"]
    pub v: [f32; 4usize],
    pub __bindgen_anon_1: _LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The x coefficient of the vector portion of the quaternion. @since 3.1.2"]
    pub x: f32,
    #[doc = " The y coefficient of the vector portion of the quaternion. @since 3.1.2"]
    pub y: f32,
    #[doc = " The z coefficient of the vector portion of the quaternion. @since 3.1.2"]
    pub z: f32,
    #[doc = " The scalar portion of the quaternion. @since 3.1.2"]
    pub w: f32,
}
#[test]
fn bindgen_test_layout__LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_QUATERNION__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[test]
fn bindgen_test_layout__LEAP_QUATERNION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_QUATERNION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_LEAP_QUATERNION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_QUATERNION__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_QUATERNION__bindgen_ty_1))
    );
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_QUATERNION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_QUATERNION__bindgen_ty_1),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
}
#[test]
fn bindgen_test_layout__LEAP_QUATERNION() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_QUATERNION>(),
        16usize,
        concat!("Size of: ", stringify!(_LEAP_QUATERNION))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_QUATERNION>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_QUATERNION))
    );
}
#[doc = " \\ingroup Structs"]
#[doc = " A four element, floating point quaternion. @since 3.1.2"]
pub type LEAP_QUATERNION = _LEAP_QUATERNION;
#[doc = " \\ingroup Structs"]
#[doc = " Describes a bone's position and orientation."]
#[doc = ""]
#[doc = " Bones are members of the LEAP_DIGIT struct."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_BONE {
    #[doc = " The base of the bone, closer to the heart. The bones origin. @since 3.0.0"]
    pub prev_joint: LEAP_VECTOR,
    #[doc = " The end of the bone, further from the heart. @since 3.0.0"]
    pub next_joint: LEAP_VECTOR,
    #[doc = " The average width of the flesh around the bone in millimeters. @since 3.0.0"]
    pub width: f32,
    #[doc = " Rotation in world space from the forward direction."]
    #[doc = " Convert the quaternion to a matrix to derive the basis vectors."]
    #[doc = " @since 3.1.2"]
    pub rotation: LEAP_QUATERNION,
}
#[test]
fn bindgen_test_layout__LEAP_BONE() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_BONE>(),
        44usize,
        concat!("Size of: ", stringify!(_LEAP_BONE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_BONE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_BONE))
    );
    fn test_field_prev_joint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_BONE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev_joint) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_BONE),
                "::",
                stringify!(prev_joint)
            )
        );
    }
    test_field_prev_joint();
    fn test_field_next_joint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_BONE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_joint) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_BONE),
                "::",
                stringify!(next_joint)
            )
        );
    }
    test_field_next_joint();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_BONE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_BONE),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_BONE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_BONE),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
}
#[doc = " \\ingroup Structs"]
#[doc = " Describes a bone's position and orientation."]
#[doc = ""]
#[doc = " Bones are members of the LEAP_DIGIT struct."]
#[doc = " @since 3.0.0"]
pub type LEAP_BONE = _LEAP_BONE;
#[doc = " \\ingroup Structs"]
#[doc = " Describes the digit of a hand."]
#[doc = " Digits are members of the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_DIGIT {
    #[doc = " The Leap identifier of this finger. @since 3.0.0"]
    pub finger_id: i32,
    pub __bindgen_anon_1: _LEAP_DIGIT__bindgen_ty_1,
    #[doc = " Reports whether the finger is more or less straight. @since 3.0.0"]
    pub is_extended: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LEAP_DIGIT__bindgen_ty_1 {
    #[doc = " All the bones of a digit as an iterable collection. @since 3.0.0"]
    pub bones: [LEAP_BONE; 4usize],
    pub __bindgen_anon_1: _LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The finger bone wholly inside the hand."]
    #[doc = " For thumbs, this bone is set to have zero length and width, an identity basis matrix,"]
    #[doc = " and its joint positions are equal."]
    #[doc = " Note that this is anatomically incorrect; in anatomical terms, the intermediate phalange"]
    #[doc = " is absent in a real thumb, rather than the metacarpal bone. In the Ultraleap Tracking model,"]
    #[doc = " however, we use a \"zero\" metacarpal bone instead for ease of programming."]
    #[doc = " @since 3.0.0"]
    pub metacarpal: LEAP_BONE,
    #[doc = " The phalange extending from the knuckle. @since 3.0.0"]
    pub proximal: LEAP_BONE,
    #[doc = " The bone between the proximal phalange and the distal phalange. @since 3.0.0"]
    pub intermediate: LEAP_BONE,
    #[doc = " The distal phalange terminating at the finger tip. @since 3.0.0"]
    pub distal: LEAP_BONE,
}
#[test]
fn bindgen_test_layout__LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>(),
        176usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_metacarpal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).metacarpal) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(metacarpal)
            )
        );
    }
    test_field_metacarpal();
    fn test_field_proximal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proximal) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(proximal)
            )
        );
    }
    test_field_proximal();
    fn test_field_intermediate() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intermediate) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(intermediate)
            )
        );
    }
    test_field_intermediate();
    fn test_field_distal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).distal) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(distal)
            )
        );
    }
    test_field_distal();
}
#[test]
fn bindgen_test_layout__LEAP_DIGIT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DIGIT__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(_LEAP_DIGIT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DIGIT__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DIGIT__bindgen_ty_1))
    );
    fn test_field_bones() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DIGIT__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bones) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT__bindgen_ty_1),
                "::",
                stringify!(bones)
            )
        );
    }
    test_field_bones();
}
#[test]
fn bindgen_test_layout__LEAP_DIGIT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DIGIT>(),
        184usize,
        concat!("Size of: ", stringify!(_LEAP_DIGIT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DIGIT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DIGIT))
    );
    fn test_field_finger_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DIGIT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finger_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT),
                "::",
                stringify!(finger_id)
            )
        );
    }
    test_field_finger_id();
    fn test_field_is_extended() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DIGIT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_extended) as usize - ptr as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DIGIT),
                "::",
                stringify!(is_extended)
            )
        );
    }
    test_field_is_extended();
}
#[doc = " \\ingroup Structs"]
#[doc = " Describes the digit of a hand."]
#[doc = " Digits are members of the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
pub type LEAP_DIGIT = _LEAP_DIGIT;
#[doc = " \\ingroup Structs"]
#[doc = " Properties associated with the palm of the hand."]
#[doc = " The Palm is a member of the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_PALM {
    #[doc = " The center position of the palm in millimeters from the Ultraleap Tracking camera device origin."]
    #[doc = " @since 3.0.0"]
    pub position: LEAP_VECTOR,
    #[doc = " The time-filtered and stabilized position of the palm."]
    #[doc = ""]
    #[doc = " Smoothing and stabilization is performed in order to make"]
    #[doc = " this value more suitable for interaction with 2D content. The stabilized"]
    #[doc = " position lags behind the palm position by a variable amount, depending"]
    #[doc = " primarily on the speed of movement."]
    #[doc = " @since 3.0.0"]
    pub stabilized_position: LEAP_VECTOR,
    #[doc = " The rate of change of the palm position in millimeters per second."]
    #[doc = " @since 3.0.0"]
    pub velocity: LEAP_VECTOR,
    #[doc = " The normal vector to the palm. If your hand is flat, this vector will"]
    #[doc = " point downward, or \"out\" of the front surface of your palm."]
    #[doc = " @since 3.0.0"]
    pub normal: LEAP_VECTOR,
    #[doc = " The estimated width of the palm when the hand is in a flat position."]
    #[doc = " @since 3.0.0"]
    pub width: f32,
    #[doc = " The unit direction vector pointing from the palm position toward the fingers."]
    #[doc = " @since 3.0.0"]
    pub direction: LEAP_VECTOR,
    #[doc = " The quaternion representing the palm's orientation"]
    #[doc = " corresponding to the basis {normal x direction, -normal, -direction}"]
    #[doc = " @since 3.1.3"]
    pub orientation: LEAP_QUATERNION,
}
#[test]
fn bindgen_test_layout__LEAP_PALM() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_PALM>(),
        80usize,
        concat!("Size of: ", stringify!(_LEAP_PALM))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_PALM>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_PALM))
    );
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
    fn test_field_stabilized_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stabilized_position) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(stabilized_position)
            )
        );
    }
    test_field_stabilized_position();
    fn test_field_velocity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(velocity)
            )
        );
    }
    test_field_velocity();
    fn test_field_normal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).normal) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(normal)
            )
        );
    }
    test_field_normal();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_direction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(direction)
            )
        );
    }
    test_field_direction();
    fn test_field_orientation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_PALM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_PALM),
                "::",
                stringify!(orientation)
            )
        );
    }
    test_field_orientation();
}
#[doc = " \\ingroup Structs"]
#[doc = " Properties associated with the palm of the hand."]
#[doc = " The Palm is a member of the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
pub type LEAP_PALM = _LEAP_PALM;
#[doc = " A left hand. @since 3.0.0"]
pub const _eLeapHandType_eLeapHandType_Left: _eLeapHandType = 0;
#[doc = " A right hand. @since 3.0.0"]
pub const _eLeapHandType_eLeapHandType_Right: _eLeapHandType = 1;
#[doc = "  \\ingroup Enum"]
#[doc = " The Hand chirality types."]
#[doc = " Used in the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
pub type _eLeapHandType = ::std::os::raw::c_int;
#[doc = "  \\ingroup Enum"]
#[doc = " The Hand chirality types."]
#[doc = " Used in the LEAP_HAND struct."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapHandType as eLeapHandType;
#[doc = " \\ingroup Structs"]
#[doc = " Describes a tracked hand. @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_HAND {
    #[doc = " A unique ID for a hand tracked across frames."]
    #[doc = " If tracking of a physical hand is lost, a new ID is assigned when"]
    #[doc = " tracking is reacquired."]
    #[doc = " @since 3.0.0"]
    pub id: u32,
    #[doc = " Reserved for future use. @since 3.0.0"]
    pub flags: u32,
    #[doc = " Identifies the chirality of this hand. @since 3.0.0"]
    pub type_: eLeapHandType,
    #[doc = " How confident we are with a given hand pose. Not currently used (always 1.0)."]
    #[doc = " @since 3.0.0"]
    pub confidence: f32,
    #[doc = " The total amount of time this hand has been tracked, in microseconds."]
    #[doc = " @since 3.0.0"]
    pub visible_time: u64,
    #[doc = " The distance between index finger and thumb. @since 3.0.0"]
    pub pinch_distance: f32,
    #[doc = " The average angle of fingers to palm. @since 3.0.0"]
    pub grab_angle: f32,
    #[doc = " The normalized estimate of the pinch pose."]
    #[doc = " Zero is not pinching; one is fully pinched."]
    #[doc = " @since 3.0.0"]
    pub pinch_strength: f32,
    #[doc = " The normalized estimate of the grab hand pose."]
    #[doc = " Zero is not grabbing; one is fully grabbing."]
    #[doc = " @since 3.0.0"]
    pub grab_strength: f32,
    #[doc = " Additional information associated with the palm. @since 3.0.0"]
    pub palm: LEAP_PALM,
    pub __bindgen_anon_1: _LEAP_HAND__bindgen_ty_1,
    #[doc = " The arm to which this hand is attached."]
    #[doc = " An arm consists of a single LEAP_BONE struct."]
    #[doc = " @since 3.0.0"]
    pub arm: LEAP_BONE,
}
#[doc = " The fingers of this hand. @since 3.0.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LEAP_HAND__bindgen_ty_1 {
    pub __bindgen_anon_1: _LEAP_HAND__bindgen_ty_1__bindgen_ty_1,
    #[doc = " The fingers of the hand as an array. @since 3.0.0"]
    pub digits: [LEAP_DIGIT; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LEAP_HAND__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The thumb. @since 3.0.0"]
    pub thumb: LEAP_DIGIT,
    #[doc = " The index finger. @since 3.0.0"]
    pub index: LEAP_DIGIT,
    #[doc = " The middle finger. @since 3.0.0"]
    pub middle: LEAP_DIGIT,
    #[doc = " The ring finger. @since 3.0.0"]
    pub ring: LEAP_DIGIT,
    #[doc = " The pinky finger. @since 3.0.0"]
    pub pinky: LEAP_DIGIT,
}
#[test]
fn bindgen_test_layout__LEAP_HAND__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>(),
        920usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_thumb() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thumb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(thumb)
            )
        );
    }
    test_field_thumb();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_middle() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).middle) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(middle)
            )
        );
    }
    test_field_middle();
    fn test_field_ring() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ring) as usize - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ring)
            )
        );
    }
    test_field_ring();
    fn test_field_pinky() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pinky) as usize - ptr as usize
            },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(pinky)
            )
        );
    }
    test_field_pinky();
}
#[test]
fn bindgen_test_layout__LEAP_HAND__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_HAND__bindgen_ty_1>(),
        920usize,
        concat!("Size of: ", stringify!(_LEAP_HAND__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_HAND__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_HAND__bindgen_ty_1))
    );
    fn test_field_digits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).digits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND__bindgen_ty_1),
                "::",
                stringify!(digits)
            )
        );
    }
    test_field_digits();
}
#[test]
fn bindgen_test_layout__LEAP_HAND() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_HAND>(),
        1084usize,
        concat!("Size of: ", stringify!(_LEAP_HAND))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_HAND>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_HAND))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_confidence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(confidence)
            )
        );
    }
    test_field_confidence();
    fn test_field_visible_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visible_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(visible_time)
            )
        );
    }
    test_field_visible_time();
    fn test_field_pinch_distance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pinch_distance) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(pinch_distance)
            )
        );
    }
    test_field_pinch_distance();
    fn test_field_grab_angle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).grab_angle) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(grab_angle)
            )
        );
    }
    test_field_grab_angle();
    fn test_field_pinch_strength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pinch_strength) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(pinch_strength)
            )
        );
    }
    test_field_pinch_strength();
    fn test_field_grab_strength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).grab_strength) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(grab_strength)
            )
        );
    }
    test_field_grab_strength();
    fn test_field_palm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).palm) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(palm)
            )
        );
    }
    test_field_palm();
    fn test_field_arm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HAND>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arm) as usize - ptr as usize
            },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HAND),
                "::",
                stringify!(arm)
            )
        );
    }
    test_field_arm();
}
#[doc = " \\ingroup Structs"]
#[doc = " Describes a tracked hand. @since 3.0.0"]
pub type LEAP_HAND = _LEAP_HAND;
#[doc = " \\ingroup Structs"]
#[doc = " A snapshot, or frame of data, containing the tracking data for a single moment in time."]
#[doc = " The LEAP_FRAME struct is the container for all the tracking data."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_TRACKING_EVENT {
    #[doc = " A universal frame identification header. @since 3.0.0"]
    pub info: LEAP_FRAME_HEADER,
    #[doc = " An identifier for this tracking frame. This identifier is meant to be monotonically"]
    #[doc = " increasing, but values may be skipped if the client application does not poll for messages"]
    #[doc = " fast enough. This number also generally increases at the same rate as info.frame_id, but"]
    #[doc = " if the server cannot process every image received from the device cameras, the info.frame_id"]
    #[doc = " identifier may increase faster."]
    #[doc = " @since 3.0.0"]
    pub tracking_frame_id: i64,
    #[doc = " The number of hands tracked in this frame, i.e. the number of elements in"]
    #[doc = " the pHands array."]
    #[doc = " @since 3.0.0"]
    pub nHands: u32,
    #[doc = " A pointer to the array of hands tracked in this frame."]
    #[doc = " @since 3.0.0"]
    pub pHands: *mut LEAP_HAND,
    #[doc = " Current tracking frame rate in hertz."]
    #[doc = ""]
    #[doc = " This frame rate is distinct from the image frame rate, which is the rate that images are"]
    #[doc = " being read from the device. Depending on host CPU limitations, the tracking frame rate"]
    #[doc = " may be substantially less than the device frame rate."]
    #[doc = ""]
    #[doc = " This number is generally equal to or less than the device frame rate, but there is one"]
    #[doc = " case where this number may be _higher_ than the device frame rate:  When the device rate"]
    #[doc = " drops. In this case, the device frame rate will fall sooner than the tracking frame rate."]
    #[doc = ""]
    #[doc = " This number is equal to zero if there are not enough frames to estimate frame rate."]
    #[doc = ""]
    #[doc = " This number cannot be negative."]
    #[doc = " @since 3.0.0"]
    pub framerate: f32,
}
#[test]
fn bindgen_test_layout__LEAP_TRACKING_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_TRACKING_EVENT>(),
        48usize,
        concat!("Size of: ", stringify!(_LEAP_TRACKING_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_TRACKING_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_TRACKING_EVENT))
    );
    fn test_field_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_EVENT),
                "::",
                stringify!(info)
            )
        );
    }
    test_field_info();
    fn test_field_tracking_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tracking_frame_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_EVENT),
                "::",
                stringify!(tracking_frame_id)
            )
        );
    }
    test_field_tracking_frame_id();
    fn test_field_nHands() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nHands) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_EVENT),
                "::",
                stringify!(nHands)
            )
        );
    }
    test_field_nHands();
    fn test_field_pHands() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pHands) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_EVENT),
                "::",
                stringify!(pHands)
            )
        );
    }
    test_field_pHands();
    fn test_field_framerate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TRACKING_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TRACKING_EVENT),
                "::",
                stringify!(framerate)
            )
        );
    }
    test_field_framerate();
}
#[doc = " \\ingroup Structs"]
#[doc = " A snapshot, or frame of data, containing the tracking data for a single moment in time."]
#[doc = " The LEAP_FRAME struct is the container for all the tracking data."]
#[doc = " @since 3.0.0"]
pub type LEAP_TRACKING_EVENT = _LEAP_TRACKING_EVENT;
#[doc = " The message severity is not known or was not specified. @since 3.0.0"]
pub const _eLeapLogSeverity_eLeapLogSeverity_Unknown: _eLeapLogSeverity = 0;
#[doc = " A message about a fault that could render the software or device non-functional. @since 3.0.0"]
pub const _eLeapLogSeverity_eLeapLogSeverity_Critical: _eLeapLogSeverity = 1;
#[doc = " A message warning about a condition that could degrade device capabilities. @since 3.0.0"]
pub const _eLeapLogSeverity_eLeapLogSeverity_Warning: _eLeapLogSeverity = 2;
#[doc = " A system status message. @since 3.0.0"]
pub const _eLeapLogSeverity_eLeapLogSeverity_Information: _eLeapLogSeverity = 3;
#[doc = " \\ingroup Enum"]
#[doc = " System message severity types. @since 3.0.0"]
pub type _eLeapLogSeverity = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " System message severity types. @since 3.0.0"]
pub use self::_eLeapLogSeverity as eLeapLogSeverity;
#[doc = " \\ingroup Structs"]
#[doc = " A system log message. @since 3.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_LOG_EVENT {
    #[doc = " The type of message. @since 4.0.0"]
    pub severity: eLeapLogSeverity,
    #[doc = " The timestamp of the message in microseconds."]
    #[doc = " Compare with the current values of LeapGetNow() and the system clock to"]
    #[doc = " calculate the absolute time of the message."]
    #[doc = " @since 4.0.0"]
    pub timestamp: i64,
    #[doc = " A pointer to a null-terminated string containing the current log message."]
    #[doc = " @since 4.0.0"]
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__LEAP_LOG_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_LOG_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(_LEAP_LOG_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_LOG_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_LOG_EVENT))
    );
    fn test_field_severity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_LOG_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).severity) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_LOG_EVENT),
                "::",
                stringify!(severity)
            )
        );
    }
    test_field_severity();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_LOG_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_LOG_EVENT),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_LOG_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_LOG_EVENT),
                "::",
                stringify!(message)
            )
        );
    }
    test_field_message();
}
#[doc = " \\ingroup Structs"]
#[doc = " A system log message. @since 3.0.0"]
pub type LEAP_LOG_EVENT = _LEAP_LOG_EVENT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_LOG_EVENTS {
    #[doc = " The number of log events being pointed to by the events field."]
    #[doc = " @since 4.0.0"]
    pub nEvents: u32,
    #[doc = " An array of ``nEvent`` LEAP_LOG_EVENT structures."]
    #[doc = " @since 4.0.0"]
    pub events: *mut LEAP_LOG_EVENT,
}
#[test]
fn bindgen_test_layout__LEAP_LOG_EVENTS() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_LOG_EVENTS>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_LOG_EVENTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_LOG_EVENTS>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_LOG_EVENTS))
    );
    fn test_field_nEvents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_LOG_EVENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nEvents) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_LOG_EVENTS),
                "::",
                stringify!(nEvents)
            )
        );
    }
    test_field_nEvents();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_LOG_EVENTS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_LOG_EVENTS),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
}
pub type LEAP_LOG_EVENTS = _LEAP_LOG_EVENTS;
#[doc = " \\ingroup Structs"]
#[doc = " A notification that a device's status has changed. One of these messages is received by the client"]
#[doc = " as soon as the service is connected, or when a new device is attached."]
#[doc = " @since 3.1.3"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DEVICE_STATUS_CHANGE_EVENT {
    #[doc = " A reference to the device whose status has changed"]
    pub device: LEAP_DEVICE_REF,
    #[doc = " The last known status of the device. This is a combination of eLeapDeviceStatus flags. @since 3.1.3"]
    pub last_status: u32,
    #[doc = " The current status of the device. This is a combination of eLeapDeviceStatus flags. @since 3.1.3"]
    pub status: u32,
}
#[test]
fn bindgen_test_layout__LEAP_DEVICE_STATUS_CHANGE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DEVICE_STATUS_CHANGE_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(_LEAP_DEVICE_STATUS_CHANGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DEVICE_STATUS_CHANGE_EVENT>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_DEVICE_STATUS_CHANGE_EVENT)
        )
    );
    fn test_field_device() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_STATUS_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_STATUS_CHANGE_EVENT),
                "::",
                stringify!(device)
            )
        );
    }
    test_field_device();
    fn test_field_last_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_STATUS_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_status) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_STATUS_CHANGE_EVENT),
                "::",
                stringify!(last_status)
            )
        );
    }
    test_field_last_status();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DEVICE_STATUS_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DEVICE_STATUS_CHANGE_EVENT),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[doc = " \\ingroup Structs"]
#[doc = " A notification that a device's status has changed. One of these messages is received by the client"]
#[doc = " as soon as the service is connected, or when a new device is attached."]
#[doc = " @since 3.1.3"]
pub type LEAP_DEVICE_STATUS_CHANGE_EVENT = _LEAP_DEVICE_STATUS_CHANGE_EVENT;
pub const _eLeapDroppedFrameType_eLeapDroppedFrameType_PreprocessingQueue: _eLeapDroppedFrameType =
    0;
pub const _eLeapDroppedFrameType_eLeapDroppedFrameType_TrackingQueue: _eLeapDroppedFrameType = 1;
pub const _eLeapDroppedFrameType_eLeapDroppedFrameType_Other: _eLeapDroppedFrameType = 2;
pub type _eLeapDroppedFrameType = ::std::os::raw::c_int;
pub use self::_eLeapDroppedFrameType as eLeapDroppedFrameType;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_DROPPED_FRAME_EVENT {
    pub frame_id: i64,
    pub type_: eLeapDroppedFrameType,
}
#[test]
fn bindgen_test_layout__LEAP_DROPPED_FRAME_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_DROPPED_FRAME_EVENT>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_DROPPED_FRAME_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_DROPPED_FRAME_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_DROPPED_FRAME_EVENT))
    );
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DROPPED_FRAME_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DROPPED_FRAME_EVENT),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_DROPPED_FRAME_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_DROPPED_FRAME_EVENT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
pub type LEAP_DROPPED_FRAME_EVENT = _LEAP_DROPPED_FRAME_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " An image associated with a frame of data."]
#[doc = " @since 4.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_IMAGE {
    #[doc = " The properties of the received image."]
    pub properties: LEAP_IMAGE_PROPERTIES,
    #[doc = " A version number for the distortion matrix. When the distortion matrix"]
    #[doc = " changes, this number is updated. This number is guaranteed not to repeat"]
    #[doc = " for the lifetime of the connection. This version number is also guaranteed"]
    #[doc = " to be distinct for each perspective of an image."]
    #[doc = ""]
    #[doc = " This value is guaranteed to be nonzero if it is valid."]
    #[doc = ""]
    #[doc = " The distortion matrix only changes when the streaming device changes or when the"]
    #[doc = " device orientation flips -- inverting the image and the distortion grid."]
    #[doc = " Since building a matrix to undistort an image can be a time-consuming task,"]
    #[doc = " you can optimize the process by only rebuilding this matrix (or whatever"]
    #[doc = " data type you use to correct image distortion) when the grid actually changes."]
    pub matrix_version: u64,
    #[doc = " Pointers to the camera's distortion matrix."]
    pub distortion_matrix: *mut LEAP_DISTORTION_MATRIX,
    #[doc = " A pointer to the image data."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Offset, in bytes, from the beginning of the data ptr to the actual beginning of the image data"]
    pub offset: u32,
}
#[test]
fn bindgen_test_layout__LEAP_IMAGE() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_IMAGE>(),
        64usize,
        concat!("Size of: ", stringify!(_LEAP_IMAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_IMAGE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_IMAGE))
    );
    fn test_field_properties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE),
                "::",
                stringify!(properties)
            )
        );
    }
    test_field_properties();
    fn test_field_matrix_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matrix_version) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE),
                "::",
                stringify!(matrix_version)
            )
        );
    }
    test_field_matrix_version();
    fn test_field_distortion_matrix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).distortion_matrix) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE),
                "::",
                stringify!(distortion_matrix)
            )
        );
    }
    test_field_distortion_matrix();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
#[doc = " \\ingroup Structs"]
#[doc = " An image associated with a frame of data."]
#[doc = " @since 4.0.0"]
pub type LEAP_IMAGE = _LEAP_IMAGE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_POINT_MAPPING_CHANGE_EVENT {
    #[doc = " The ID of the frame corresponding to the source of the currently tracked points. @since 4.0.0"]
    pub frame_id: i64,
    #[doc = " The timestamp of the frame, in microseconds, referenced against LeapGetNow(). @since 4.0.0"]
    pub timestamp: i64,
    #[doc = " The number of points being tracked. @since 4.0.0"]
    pub nPoints: u32,
}
#[test]
fn bindgen_test_layout__LEAP_POINT_MAPPING_CHANGE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_POINT_MAPPING_CHANGE_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(_LEAP_POINT_MAPPING_CHANGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_POINT_MAPPING_CHANGE_EVENT>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_POINT_MAPPING_CHANGE_EVENT)
        )
    );
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING_CHANGE_EVENT),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING_CHANGE_EVENT),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_nPoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING_CHANGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nPoints) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING_CHANGE_EVENT),
                "::",
                stringify!(nPoints)
            )
        );
    }
    test_field_nPoints();
}
pub type LEAP_POINT_MAPPING_CHANGE_EVENT = _LEAP_POINT_MAPPING_CHANGE_EVENT;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_POINT_MAPPING {
    #[doc = " The ID of the frame corresponding to the source of the currently tracked points. @since 4.0.0"]
    pub frame_id: i64,
    #[doc = " The timestamp of the frame, in microseconds, referenced against LeapGetNow(). @since 4.0.0"]
    pub timestamp: i64,
    #[doc = " The number of points being tracked. @since 4.0.0"]
    pub nPoints: u32,
    #[doc = " The 3D points being mapped. @since 4.0.0"]
    pub pPoints: *mut LEAP_VECTOR,
    #[doc = " The IDs of the 3D points being mapped. @since 4.0.0"]
    pub pIDs: *mut u32,
}
#[test]
fn bindgen_test_layout__LEAP_POINT_MAPPING() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_POINT_MAPPING>(),
        36usize,
        concat!("Size of: ", stringify!(_LEAP_POINT_MAPPING))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_POINT_MAPPING>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_POINT_MAPPING))
    );
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_nPoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nPoints) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING),
                "::",
                stringify!(nPoints)
            )
        );
    }
    test_field_nPoints();
    fn test_field_pPoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPoints) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING),
                "::",
                stringify!(pPoints)
            )
        );
    }
    test_field_pPoints();
    fn test_field_pIDs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_POINT_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pIDs) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_POINT_MAPPING),
                "::",
                stringify!(pIDs)
            )
        );
    }
    test_field_pIDs();
}
pub type LEAP_POINT_MAPPING = _LEAP_POINT_MAPPING;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_HEAD_POSE_EVENT {
    #[doc = " The timestamp for this image, in microseconds, referenced against LeapGetNow()."]
    #[doc = " @since 4.1.0"]
    pub timestamp: i64,
    #[doc = " The position and orientation of the user's head. Positional tracking must be enabled."]
    #[doc = " @since 4.1.0"]
    pub head_position: LEAP_VECTOR,
    pub head_orientation: LEAP_QUATERNION,
    #[doc = " The linear and angular velocity of the user's head. Positional tracking must be enabled."]
    #[doc = " @since 4.1.0"]
    pub head_linear_velocity: LEAP_VECTOR,
    pub head_angular_velocity: LEAP_VECTOR,
}
#[test]
fn bindgen_test_layout__LEAP_HEAD_POSE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_HEAD_POSE_EVENT>(),
        60usize,
        concat!("Size of: ", stringify!(_LEAP_HEAD_POSE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_HEAD_POSE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_HEAD_POSE_EVENT))
    );
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HEAD_POSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HEAD_POSE_EVENT),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_head_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HEAD_POSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head_position) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HEAD_POSE_EVENT),
                "::",
                stringify!(head_position)
            )
        );
    }
    test_field_head_position();
    fn test_field_head_orientation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HEAD_POSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head_orientation) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HEAD_POSE_EVENT),
                "::",
                stringify!(head_orientation)
            )
        );
    }
    test_field_head_orientation();
    fn test_field_head_linear_velocity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HEAD_POSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head_linear_velocity) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HEAD_POSE_EVENT),
                "::",
                stringify!(head_linear_velocity)
            )
        );
    }
    test_field_head_linear_velocity();
    fn test_field_head_angular_velocity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_HEAD_POSE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head_angular_velocity) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_HEAD_POSE_EVENT),
                "::",
                stringify!(head_angular_velocity)
            )
        );
    }
    test_field_head_angular_velocity();
}
pub type LEAP_HEAD_POSE_EVENT = _LEAP_HEAD_POSE_EVENT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_EYE_EVENT {
    #[doc = " The ID of the frame corresponding to the source of the currently tracked"]
    #[doc = " eye positions."]
    #[doc = " @since 4.1.0"]
    pub frame_id: i64,
    #[doc = " The timestamp for this image, in microseconds, referenced against"]
    #[doc = " LeapGetNow()."]
    #[doc = " @since 4.1.0"]
    pub timestamp: i64,
    #[doc = " The position of the user's left eye."]
    #[doc = " @since 4.1.0"]
    pub left_eye_position: LEAP_VECTOR,
    #[doc = " The position of the user's right eye."]
    #[doc = " @since 4.1.0"]
    pub right_eye_position: LEAP_VECTOR,
    #[doc = " An error estimate of the tracked left eye position. Higher values indicate"]
    #[doc = " uncertain tracking and a higher likelihood of there being no such eye in"]
    #[doc = " view of the sensor."]
    #[doc = " @since 4.1.0"]
    pub left_eye_estimated_error: f32,
    #[doc = " An error estimate of the tracked right eye position. Higher values indicate"]
    #[doc = " uncertain tracking and a higher likelihood of there being no such eye in"]
    #[doc = " view of the sensor."]
    #[doc = " @since 4.1.0"]
    pub right_eye_estimated_error: f32,
}
#[test]
fn bindgen_test_layout__LEAP_EYE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_EYE_EVENT>(),
        48usize,
        concat!("Size of: ", stringify!(_LEAP_EYE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_EYE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_EYE_EVENT))
    );
    fn test_field_frame_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(frame_id)
            )
        );
    }
    test_field_frame_id();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_left_eye_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left_eye_position) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(left_eye_position)
            )
        );
    }
    test_field_left_eye_position();
    fn test_field_right_eye_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right_eye_position) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(right_eye_position)
            )
        );
    }
    test_field_right_eye_position();
    fn test_field_left_eye_estimated_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left_eye_estimated_error) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(left_eye_estimated_error)
            )
        );
    }
    test_field_left_eye_estimated_error();
    fn test_field_right_eye_estimated_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_EYE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right_eye_estimated_error) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_EYE_EVENT),
                "::",
                stringify!(right_eye_estimated_error)
            )
        );
    }
    test_field_right_eye_estimated_error();
}
pub type LEAP_EYE_EVENT = _LEAP_EYE_EVENT;
#[doc = " Has accelerometer measurements. @since 4.1.0"]
pub const _eLeapIMUFlag_eLeapIMUFlag_HasAccelerometer: _eLeapIMUFlag = 1;
#[doc = " Has gyroscope measurements. @since 4.1.0"]
pub const _eLeapIMUFlag_eLeapIMUFlag_HasGyroscope: _eLeapIMUFlag = 2;
#[doc = " Has a temperature measurement. @since 4.1.0"]
pub const _eLeapIMUFlag_eLeapIMUFlag_HasTemperature: _eLeapIMUFlag = 4;
pub type _eLeapIMUFlag = ::std::os::raw::c_int;
pub use self::_eLeapIMUFlag as eLeapIMUFlag;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_IMU_EVENT {
    #[doc = " The timestamp for these measurements, in microseconds, referenced against"]
    #[doc = " LeapGetNow()."]
    #[doc = " @since 4.1.0"]
    pub timestamp: i64,
    #[doc = " The timestamp for these measurements, in microseconds, referenced against"]
    #[doc = " the device's internal clock."]
    #[doc = " @since 4.1.0"]
    pub timestamp_hw: i64,
    #[doc = " A combination of eLeapIMUFlag flags."]
    #[doc = " @since 4.1.0"]
    pub flags: u32,
    #[doc = " The accelerometer measurements, in m/s^2."]
    #[doc = " @since 4.1.0"]
    pub accelerometer: LEAP_VECTOR,
    #[doc = " The gyroscope measurements, in rad/s."]
    #[doc = " @since 4.1.0"]
    pub gyroscope: LEAP_VECTOR,
    #[doc = " The measured temperature, in deg C."]
    #[doc = " @since 4.1.0"]
    pub temperature: f32,
}
#[test]
fn bindgen_test_layout__LEAP_IMU_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_IMU_EVENT>(),
        48usize,
        concat!("Size of: ", stringify!(_LEAP_IMU_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_IMU_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_IMU_EVENT))
    );
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_timestamp_hw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp_hw) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(timestamp_hw)
            )
        );
    }
    test_field_timestamp_hw();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_accelerometer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerometer) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(accelerometer)
            )
        );
    }
    test_field_accelerometer();
    fn test_field_gyroscope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gyroscope) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(gyroscope)
            )
        );
    }
    test_field_gyroscope();
    fn test_field_temperature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMU_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMU_EVENT),
                "::",
                stringify!(temperature)
            )
        );
    }
    test_field_temperature();
}
pub type LEAP_IMU_EVENT = _LEAP_IMU_EVENT;
#[doc = " \\ingroup Structs"]
#[doc = " Streaming stereo image pairs from the device."]
#[doc = ""]
#[doc = " LeapPollConnection() produces this message when an image is available."]
#[doc = " The struct contains image properties, the distortion grid, and a pointer to"]
#[doc = " the buffer containing the image data -- which was allocated using the allocator"]
#[doc = " function passed to LeapC using the LeapSetAllocator."]
#[doc = " @since 4.0.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_IMAGE_EVENT {
    #[doc = " The information header identifying the images tracking frame."]
    pub info: LEAP_FRAME_HEADER,
    #[doc = " The left and right images."]
    pub image: [LEAP_IMAGE; 2usize],
    #[doc = " For internal use only."]
    pub calib: LEAP_CALIBRATION,
}
#[test]
fn bindgen_test_layout__LEAP_IMAGE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_IMAGE_EVENT>(),
        160usize,
        concat!("Size of: ", stringify!(_LEAP_IMAGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_IMAGE_EVENT>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_IMAGE_EVENT))
    );
    fn test_field_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_EVENT),
                "::",
                stringify!(info)
            )
        );
    }
    test_field_info();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_EVENT),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_calib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_IMAGE_EVENT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).calib) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_IMAGE_EVENT),
                "::",
                stringify!(calib)
            )
        );
    }
    test_field_calib();
}
#[doc = " \\ingroup Structs"]
#[doc = " Streaming stereo image pairs from the device."]
#[doc = ""]
#[doc = " LeapPollConnection() produces this message when an image is available."]
#[doc = " The struct contains image properties, the distortion grid, and a pointer to"]
#[doc = " the buffer containing the image data -- which was allocated using the allocator"]
#[doc = " function passed to LeapC using the LeapSetAllocator."]
#[doc = " @since 4.0.0"]
pub type LEAP_IMAGE_EVENT = _LEAP_IMAGE_EVENT;
#[doc = " No event has occurred within the timeout period specified when calling LeapPollConnection()."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_None: _eLeapEventType = 0;
#[doc = " A connection to the Ultraleap Tracking Service has been established."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_Connection: _eLeapEventType = 1;
#[doc = " The connection to the Ultraleap Tracking Service has been lost."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_ConnectionLost: _eLeapEventType = 2;
#[doc = " A device has been detected or plugged-in."]
#[doc = " A device event is dispatched after a connection is established for any"]
#[doc = " devices already plugged in. (The system currently only supports one"]
#[doc = " streaming device at a time.)"]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_Device: _eLeapEventType = 3;
#[doc = " A device has failed."]
#[doc = " Device failure could be caused by hardware failure, USB controller issues, or"]
#[doc = " other system instability. Note that unplugging a device generates an"]
#[doc = " eLeapEventType_DeviceLost event message, not a failure message."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_DeviceFailure: _eLeapEventType = 4;
#[doc = " A policy change has occurred."]
#[doc = " This can be due to setting a policy with LeapSetPolicyFlags() or due to changing"]
#[doc = " or policy-related config settings, including images_mode."]
#[doc = " (A user can also change these policies using the Ultraleap Tracking Control Panel.)"]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_Policy: _eLeapEventType = 5;
#[doc = " A tracking frame. The message contains the tracking data for the frame."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_Tracking: _eLeapEventType = 256;
#[doc = " The request for an image has failed."]
#[doc = " The message contains information about the failure. The client application"]
#[doc = " will not receive the requested image set."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_ImageRequestError: _eLeapEventType = 257;
#[doc = " The request for an image is complete."]
#[doc = " The image data has been completely written to the application-provided"]
#[doc = " buffer."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_ImageComplete: _eLeapEventType = 258;
#[doc = " A system message. @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_LogEvent: _eLeapEventType = 259;
#[doc = " The device connection has been lost."]
#[doc = ""]
#[doc = " This event is generally asserted when the device has been detached from the system, when the"]
#[doc = " connection to the service has been lost, or if the device is closed while streaming. Generally,"]
#[doc = " any event where the system can conclude no further frames will be received will result in this"]
#[doc = " message. The DeviceEvent field will be filled with the id of the formerly attached device."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_DeviceLost: _eLeapEventType = 260;
#[doc = " The asynchronous response to a call to LeapRequestConfigValue()."]
#[doc = " Contains the value of requested configuration item."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_ConfigResponse: _eLeapEventType = 261;
#[doc = " The asynchronous response to a call to LeapSaveConfigValue()."]
#[doc = " Reports whether the change succeeded or failed."]
#[doc = " @since 3.0.0"]
pub const _eLeapEventType_eLeapEventType_ConfigChange: _eLeapEventType = 262;
#[doc = " Notification that a status change has been detected on an attached device"]
#[doc = ""]
#[doc = " @since 3.1.3"]
pub const _eLeapEventType_eLeapEventType_DeviceStatusChange: _eLeapEventType = 263;
#[doc = " Notification that a status change has been detected on an attached device"]
#[doc = ""]
#[doc = " @since 3.1.3"]
pub const _eLeapEventType_eLeapEventType_DroppedFrame: _eLeapEventType = 264;
#[doc = " Notification that an unrequested stereo image pair is available"]
#[doc = ""]
#[doc = " @since 4.0.0"]
pub const _eLeapEventType_eLeapEventType_Image: _eLeapEventType = 265;
#[doc = " Notification that point mapping has changed"]
#[doc = ""]
#[doc = " @since 4.0.0"]
pub const _eLeapEventType_eLeapEventType_PointMappingChange: _eLeapEventType = 266;
#[doc = " A tracking mode change has occurred."]
#[doc = " This can be due to changing the hmd or screentop policy with LeapSetPolicyFlags()."]
#[doc = " or setting the tracking mode using LeapSetTrackingMode()."]
#[doc = " @since 5.0.0"]
pub const _eLeapEventType_eLeapEventType_TrackingMode: _eLeapEventType = 267;
#[doc = " An array of system messages. @since 4.0.0"]
pub const _eLeapEventType_eLeapEventType_LogEvents: _eLeapEventType = 268;
#[doc = " A head pose. The message contains the timestamped head position and orientation."]
#[doc = " @since 4.1.0"]
pub const _eLeapEventType_eLeapEventType_HeadPose: _eLeapEventType = 269;
#[doc = " Tracked eye positions. @since 4.1.0"]
pub const _eLeapEventType_eLeapEventType_Eyes: _eLeapEventType = 270;
#[doc = " An IMU reading. @since 4.1.0"]
pub const _eLeapEventType_eLeapEventType_IMU: _eLeapEventType = 271;
#[doc = " \\ingroup Enum"]
#[doc = " The types of event messages resulting from calling LeapPollConnection()."]
#[doc = " @since 3.0.0"]
pub type _eLeapEventType = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " The types of event messages resulting from calling LeapPollConnection()."]
#[doc = " @since 3.0.0"]
pub use self::_eLeapEventType as eLeapEventType;
#[doc = " \\ingroup Structs"]
#[doc = " Defines a basic message from the LeapC message queue."]
#[doc = " Set by calling LeapPollConnection()."]
#[doc = " @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _LEAP_CONNECTION_MESSAGE {
    #[doc = " The size of this message struct. @since 3.0.0"]
    pub size: u32,
    #[doc = " The message type. @since 3.0.0"]
    pub type_: eLeapEventType,
    pub __bindgen_anon_1: _LEAP_CONNECTION_MESSAGE__bindgen_ty_1,
    #[doc = " A unique ID for the attached device that sent this message. A value of"]
    #[doc = "  0 indicates that it was a system-wide message, and not device specific."]
    #[doc = "  Use this ID to distinguish messages sent from multiple attached devices."]
    #[doc = "  @since 4.1.0"]
    pub device_id: u32,
}
#[doc = " A pointer to the event data for the current type of message. @since 3.0.0"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union _LEAP_CONNECTION_MESSAGE__bindgen_ty_1 {
    #[doc = " An untyped pointer. @since 3.0.0"]
    pub pointer: *const ::std::os::raw::c_void,
    #[doc = " A connection message. @since 3.0.0"]
    pub connection_event: *const LEAP_CONNECTION_EVENT,
    #[doc = " A connection lost. @since 3.0.0"]
    pub connection_lost_event: *const LEAP_CONNECTION_LOST_EVENT,
    #[doc = " A device detected message. @since 3.0.0"]
    pub device_event: *const LEAP_DEVICE_EVENT,
    #[doc = " A device's status has changed.  @since 3.1.3"]
    pub device_status_change_event: *const LEAP_DEVICE_STATUS_CHANGE_EVENT,
    #[doc = " A policy message. @since 3.0.0"]
    pub policy_event: *const LEAP_POLICY_EVENT,
    #[doc = " A device failure message. @since 3.0.0"]
    pub device_failure_event: *const LEAP_DEVICE_FAILURE_EVENT,
    #[doc = " A tracking message. @since 3.0.0"]
    pub tracking_event: *const LEAP_TRACKING_EVENT,
    #[doc = " A tracking mode message. @since 5.0.0"]
    pub tracking_mode_event: *const LEAP_TRACKING_MODE_EVENT,
    #[doc = " A log message. @since 3.0.0"]
    pub log_event: *const LEAP_LOG_EVENT,
    #[doc = " A log messages. @since 4.0.0"]
    pub log_events: *const LEAP_LOG_EVENTS,
    #[doc = " A get config value message. @since 3.0.0"]
    pub config_response_event: *const LEAP_CONFIG_RESPONSE_EVENT,
    #[doc = " A set config value message. @since 3.0.0"]
    pub config_change_event: *const LEAP_CONFIG_CHANGE_EVENT,
    pub dropped_frame_event: *const LEAP_DROPPED_FRAME_EVENT,
    #[doc = " A streaming image message. @since 4.0.0"]
    pub image_event: *const LEAP_IMAGE_EVENT,
    #[doc = " A point mapping message. @since 4.0.0"]
    pub point_mapping_change_event: *const LEAP_POINT_MAPPING_CHANGE_EVENT,
    #[doc = " A head pose message. @since 4.1.0"]
    pub head_pose_event: *const LEAP_HEAD_POSE_EVENT,
    #[doc = " An eye positions message for both the left and right eyes. @since 4.1.0"]
    pub eye_event: *const LEAP_EYE_EVENT,
    #[doc = " An IMU message. @since 4.1.0"]
    pub imu_event: *const LEAP_IMU_EVENT,
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_MESSAGE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1)
        )
    );
    fn test_field_pointer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(pointer)
            )
        );
    }
    test_field_pointer();
    fn test_field_connection_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connection_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(connection_event)
            )
        );
    }
    test_field_connection_event();
    fn test_field_connection_lost_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).connection_lost_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(connection_lost_event)
            )
        );
    }
    test_field_connection_lost_event();
    fn test_field_device_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(device_event)
            )
        );
    }
    test_field_device_event();
    fn test_field_device_status_change_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_status_change_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(device_status_change_event)
            )
        );
    }
    test_field_device_status_change_event();
    fn test_field_policy_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).policy_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(policy_event)
            )
        );
    }
    test_field_policy_event();
    fn test_field_device_failure_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_failure_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(device_failure_event)
            )
        );
    }
    test_field_device_failure_event();
    fn test_field_tracking_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tracking_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(tracking_event)
            )
        );
    }
    test_field_tracking_event();
    fn test_field_tracking_mode_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tracking_mode_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(tracking_mode_event)
            )
        );
    }
    test_field_tracking_mode_event();
    fn test_field_log_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(log_event)
            )
        );
    }
    test_field_log_event();
    fn test_field_log_events() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_events) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(log_events)
            )
        );
    }
    test_field_log_events();
    fn test_field_config_response_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).config_response_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(config_response_event)
            )
        );
    }
    test_field_config_response_event();
    fn test_field_config_change_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).config_change_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(config_change_event)
            )
        );
    }
    test_field_config_change_event();
    fn test_field_dropped_frame_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dropped_frame_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(dropped_frame_event)
            )
        );
    }
    test_field_dropped_frame_event();
    fn test_field_image_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(image_event)
            )
        );
    }
    test_field_image_event();
    fn test_field_point_mapping_change_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).point_mapping_change_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(point_mapping_change_event)
            )
        );
    }
    test_field_point_mapping_change_event();
    fn test_field_head_pose_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head_pose_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(head_pose_event)
            )
        );
    }
    test_field_head_pose_event();
    fn test_field_eye_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eye_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(eye_event)
            )
        );
    }
    test_field_eye_event();
    fn test_field_imu_event() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imu_event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE__bindgen_ty_1),
                "::",
                stringify!(imu_event)
            )
        );
    }
    test_field_imu_event();
}
#[test]
fn bindgen_test_layout__LEAP_CONNECTION_MESSAGE() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_CONNECTION_MESSAGE>(),
        20usize,
        concat!("Size of: ", stringify!(_LEAP_CONNECTION_MESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_CONNECTION_MESSAGE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_CONNECTION_MESSAGE))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_device_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_CONNECTION_MESSAGE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_CONNECTION_MESSAGE),
                "::",
                stringify!(device_id)
            )
        );
    }
    test_field_device_id();
}
#[doc = " \\ingroup Structs"]
#[doc = " Defines a basic message from the LeapC message queue."]
#[doc = " Set by calling LeapPollConnection()."]
#[doc = " @since 3.0.0"]
pub type LEAP_CONNECTION_MESSAGE = _LEAP_CONNECTION_MESSAGE;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Polls the connection for a new event."]
    #[doc = ""]
    #[doc = " The specific types of events that may be received are not configurable in this entrypoint. Configure"]
    #[doc = " the device or connection object directly to change what events will be received."]
    #[doc = ""]
    #[doc = " Pointers in the retrieved event message structure will be valid until the associated connection or device is"]
    #[doc = " closed, or the next call to LeapPollConnection()."]
    #[doc = ""]
    #[doc = " Calling this method concurrently will return eLeapRS_ConcurrentPoll."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param timeout The maximum amount of time to wait, in milliseconds. If this value is zero,"]
    #[doc = " the evt pointer references the next queued message, if there is one, and returns immediately."]
    #[doc = " @param[out] evt A pointer to a structure that is filled with event information. This structure will be valid"]
    #[doc = " as long as the LEAP_CONNECTION object is valid."]
    #[doc = ""]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration. If the operation"]
    #[doc = " times out, this method will return eLeapRS_Timeout. The evt pointer will reference a"]
    #[doc = " message of type eLeapEventType_None."]
    #[doc = " @since 3.0.0"]
    pub fn LeapPollConnection(
        hConnection: LEAP_CONNECTION,
        timeout: u32,
        evt: *mut LEAP_CONNECTION_MESSAGE,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Retrieves the number of bytes required to allocate an interpolated frame at the specified time."]
    #[doc = ""]
    #[doc = " Use this function to determine the size of the buffer to allocate when calling"]
    #[doc = " LeapInterpolateFrame()."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param timestamp The timestamp of the frame whose size is to be queried."]
    #[doc = " @param[out] pncbEvent A pointer that receives the number of bytes required to store the specified frame."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.1"]
    pub fn LeapGetFrameSize(
        hConnection: LEAP_CONNECTION,
        timestamp: i64,
        pncbEvent: *mut u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Retrieves the number of bytes required to allocate an interpolated frame at the specified time"]
    #[doc = " for a particular device."]
    #[doc = ""]
    #[doc = " Use this function to determine the size of the buffer to allocate when calling"]
    #[doc = " LeapInterpolateFrameEx()."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param timestamp The timestamp of the frame whose size is to be queried."]
    #[doc = " @param[out] pncbEvent A pointer that receives the number of bytes required to store the specified frame."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapGetFrameSizeEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        timestamp: i64,
        pncbEvent: *mut u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Constructs a frame at the specified timestamp by interpolating between measured"]
    #[doc = " frames."]
    #[doc = ""]
    #[doc = " Caller is responsible for allocating a buffer large enough to hold the data of the frame."]
    #[doc = " Use LeapGetFrameSize() to calculate the minimum size of this buffer."]
    #[doc = ""]
    #[doc = " Use LeapCreateClockRebaser(), LeapUpdateRebase(), and LeapRebaseClock() to"]
    #[doc = " synchronize time measurements in the application with time measurements in"]
    #[doc = " the Ultraleap Tracking Service. This process is required to achieve accurate, smooth"]
    #[doc = " interpolation."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param timestamp The timestamp at which to interpolate the frame data."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with an interpolated frame."]
    #[doc = " @param ncbEvent The number of bytes pointed to by pEvent."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.1"]
    pub fn LeapInterpolateFrame(
        hConnection: LEAP_CONNECTION,
        timestamp: i64,
        pEvent: *mut LEAP_TRACKING_EVENT,
        ncbEvent: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Constructs a frame at the specified timestamp for a particular device by"]
    #[doc = " interpolating between measured frames."]
    #[doc = ""]
    #[doc = " Caller is responsible for allocating a buffer large enough to hold the data of the frame."]
    #[doc = " Use LeapGetFrameSizeEx() to calculate the minimum size of this buffer."]
    #[doc = ""]
    #[doc = " Use LeapCreateClockRebaser(), LeapUpdateRebase(), and LeapRebaseClock() to"]
    #[doc = " synchronize time measurements in the application with time measurements in"]
    #[doc = " the Ultraleap Tracking Service. This process is required to achieve accurate, smooth"]
    #[doc = " interpolation."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param timestamp The timestamp at which to interpolate the frame data."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with an interpolated frame."]
    #[doc = " @param ncbEvent The number of bytes pointed to by pEvent."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapInterpolateFrameEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        timestamp: i64,
        pEvent: *mut LEAP_TRACKING_EVENT,
        ncbEvent: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Constructs a frame at the specified timestamp by interpolating between a frame near the timestamp"]
    #[doc = " and a frame near the sourceTimestamp."]
    #[doc = ""]
    #[doc = " Caller is responsible for allocating a buffer large enough to hold the data of the frame."]
    #[doc = " Use LeapGetFrameSize() to calculate the minimum size of this buffer."]
    #[doc = ""]
    #[doc = " Use LeapCreateClockRebaser(), LeapUpdateRebase(), and LeapRebaseClock() to"]
    #[doc = " synchronize time measurements in the application with time measurements in"]
    #[doc = " the Ultraleap Tracking Service. This process is required to achieve accurate, smooth"]
    #[doc = " interpolation."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param timestamp The timestamp to which to interpolate the frame data."]
    #[doc = " @param sourceTimestamp The timestamp of the beginning frame from which to interpolate the frame data."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with an interpolated frame."]
    #[doc = " @param ncbEvent The number of bytes pointed to by pEvent."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.1"]
    pub fn LeapInterpolateFrameFromTime(
        hConnection: LEAP_CONNECTION,
        timestamp: i64,
        sourceTimestamp: i64,
        pEvent: *mut LEAP_TRACKING_EVENT,
        ncbEvent: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Constructs a frame at the specified timestamp for a particular device by"]
    #[doc = " interpolating between a frame near the timestamp and a frame near the"]
    #[doc = " sourceTimestamp."]
    #[doc = ""]
    #[doc = " Caller is responsible for allocating a buffer large enough to hold the data of the frame."]
    #[doc = " Use LeapGetFrameSizeEx() to calculate the minimum size of this buffer."]
    #[doc = ""]
    #[doc = " Use LeapCreateClockRebaser(), LeapUpdateRebase(), and LeapRebaseClock() to"]
    #[doc = " synchronize time measurements in the application with time measurements in"]
    #[doc = " the Ultraleap Tracking Service. This process is required to achieve accurate, smooth"]
    #[doc = " interpolation."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param timestamp The timestamp to which to interpolate the frame data."]
    #[doc = " @param sourceTimestamp The timestamp of the beginning frame from which to interpolate the frame data."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with an interpolated frame."]
    #[doc = " @param ncbEvent The number of bytes pointed to by pEvent."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.4.0"]
    pub fn LeapInterpolateFrameFromTimeEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        timestamp: i64,
        sourceTimestamp: i64,
        pEvent: *mut LEAP_TRACKING_EVENT,
        ncbEvent: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Closes a device handle previously opened with LeapOpenDevice."]
    #[doc = ""]
    #[doc = " @param hDevice The device handle to close."]
    #[doc = " @since 3.0.0"]
    pub fn LeapCloseDevice(hDevice: LEAP_DEVICE);
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Closes a previously opened connection."]
    #[doc = ""]
    #[doc = " This method closes the specified connection object if it is opened"]
    #[doc = ""]
    #[doc = " This method never fails."]
    #[doc = ""]
    #[doc = " @param hConnection A handle to the connection object to be closed."]
    #[doc = " @since 4.0.0"]
    pub fn LeapCloseConnection(hConnection: LEAP_CONNECTION);
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Destroys a previously opened connection."]
    #[doc = ""]
    #[doc = " This method closes the specified connection object if it is opened, destroys the underlying"]
    #[doc = " object, and releases all resources associated with it."]
    #[doc = ""]
    #[doc = " This method never fails."]
    #[doc = ""]
    #[doc = " Be sure that no other functions are accessing the connection when this function is called."]
    #[doc = ""]
    #[doc = " @param hConnection A handle to the connection object to be destroyed."]
    #[doc = " @since 3.0.0"]
    pub fn LeapDestroyConnection(hConnection: LEAP_CONNECTION);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_CLOCK_REBASER {
    _unused: [u8; 0],
}
#[doc = " \\ingroup Structs"]
#[doc = " \\struct LEAP_CLOCK_REBASER"]
#[doc = " An opaque clock rebase state structure. @since 3.1.2"]
pub type LEAP_CLOCK_REBASER = *mut _LEAP_CLOCK_REBASER;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Initializes a new Leap clock-rebaser handle object."]
    #[doc = ""]
    #[doc = " Pass the filled-in LEAP_CLOCK_REBASER object to calls to LeapUpdateRebase(),"]
    #[doc = " LeapRebaseClock(), and LeapDestroyClockRebaser()."]
    #[doc = ""]
    #[doc = " @param[out] phClockRebaser The pointer to the clock-rebaser object to be initialized."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.2"]
    pub fn LeapCreateClockRebaser(phClockRebaser: *mut LEAP_CLOCK_REBASER) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Updates the relationship between the Ultraleap Tracking Service clock and the user clock."]
    #[doc = ""]
    #[doc = " When using LeapInterpolateFrame(), call this function for every graphics frame"]
    #[doc = " rendered by your application. The function should be called as close to the"]
    #[doc = " actual point of rendering as possible."]
    #[doc = ""]
    #[doc = " The relationship between the application clock and the Ultraleap Tracking Service clock is"]
    #[doc = " neither fixed nor stable. Simulation restarts can cause user clock values to change"]
    #[doc = " instantaneously. Certain systems simulate slow motion, or respond to heavy load, by reducing the tick rate"]
    #[doc = " of the user clock. As a result, the LeapUpdateRebase() function must be called for every rendered frame."]
    #[doc = ""]
    #[doc = " @param hClockRebaser The handle to a rebaser object created by LeapCreateClockRebaser()."]
    #[doc = " @param userClock A clock value supplied by the application, sampled at about the same time as LeapGetNow() was sampled."]
    #[doc = " @param leapClock The Ultraleap Tracking Service clock value sampled by a call to LeapGetNow()."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.2"]
    pub fn LeapUpdateRebase(
        hClockRebaser: LEAP_CLOCK_REBASER,
        userClock: i64,
        leapClock: i64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Computes the Ultraleap Tracking Service clock corresponding to a specified application clock value."]
    #[doc = ""]
    #[doc = " Use this function to translate your application clock to the Ultraleap Tracking Service clock"]
    #[doc = " when interpolating frames. LeapUpdateRebase() must be called for every rendered"]
    #[doc = " frame for the relationship between the two clocks to remain synchronized."]
    #[doc = ""]
    #[doc = " @param hClockRebaser The handle to a rebaser object created by LeapCreateClockRebaser()."]
    #[doc = " @param userClock The clock in microseconds referenced to the application clock."]
    #[doc = " @param[out] pLeapClock The corresponding Ultraleap Tracking Service clock value."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.1.2"]
    pub fn LeapRebaseClock(
        hClockRebaser: LEAP_CLOCK_REBASER,
        userClock: i64,
        pLeapClock: *mut i64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Destroys a previously created clock-rebaser object."]
    #[doc = ""]
    #[doc = " This method destroys the specified clock-rebaser object, and releases all resources associated with it."]
    #[doc = ""]
    #[doc = " @param hClockRebaser A handle to the clock-rebaser object to be destroyed."]
    #[doc = " @since 3.1.2"]
    pub fn LeapDestroyClockRebaser(hClockRebaser: LEAP_CLOCK_REBASER);
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Provides the corrected camera ray intercepting the specified point on the image."]
    #[doc = ""]
    #[doc = " Given a point on the image, ``LeapPixelToRectilinear()`` corrects for camera distortion"]
    #[doc = " and returns the true direction from the camera to the source of that image point"]
    #[doc = " within the Ultraleap Tracking camera field of view."]
    #[doc = ""]
    #[doc = " This direction vector has an x and y component [x, y, 1], with the third element"]
    #[doc = " always 1. Note that this vector uses the 2D camera coordinate system"]
    #[doc = " where the x-axis parallels the longer (typically horizontal) dimension and"]
    #[doc = " the y-axis parallels the shorter (vertical) dimension. The camera coordinate"]
    #[doc = " system does not correlate to the 3D Ultraleap Tracking coordinate system."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param pixel A Vector containing the position of a pixel in the image."]
    #[doc = " @returns A Vector containing the ray direction (the z-component of the vector is always 1)."]
    #[doc = " @since 3.1.3"]
    pub fn LeapPixelToRectilinear(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        pixel: LEAP_VECTOR,
    ) -> LEAP_VECTOR;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Provides the corrected camera ray intercepting the specified point"]
    #[doc = " on the image for a particular device."]
    #[doc = ""]
    #[doc = " Given a point on the image, ``LeapPixelToRectilinearEx()`` corrects for camera distortion"]
    #[doc = " and returns the true direction from the camera to the source of that image point"]
    #[doc = " within the Devices field of view."]
    #[doc = ""]
    #[doc = " This direction vector has an x and y component [x, y, 1], with the third element"]
    #[doc = " always 1. Note that this vector uses the 2D camera coordinate system"]
    #[doc = " where the x-axis parallels the longer (typically horizontal) dimension and"]
    #[doc = " the y-axis parallels the shorter (vertical) dimension. The camera coordinate"]
    #[doc = " system does not correlate to the 3D Ultraleap coordinate system."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param pixel A Vector containing the position of a pixel in the image."]
    #[doc = " @returns A Vector containing the ray direction (the z-component of the vector is always 1)."]
    #[doc = " @since 5.4.0"]
    pub fn LeapPixelToRectilinearEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        pixel: LEAP_VECTOR,
    ) -> LEAP_VECTOR;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Provides the point in the image corresponding to a ray projecting"]
    #[doc = " from the camera."]
    #[doc = ""]
    #[doc = " Given a ray projected from the camera in the specified direction, ``LeapRectilinearToPixel()``"]
    #[doc = " corrects for camera distortion and returns the corresponding pixel"]
    #[doc = " coordinates in the image."]
    #[doc = ""]
    #[doc = " The ray direction is specified in relationship to the camera. The first"]
    #[doc = " vector element is the tangent of the \"horizontal\" view angle; the second"]
    #[doc = " element is the tangent of the \"vertical\" view angle."]
    #[doc = ""]
    #[doc = " The ``LeapRectilinearToPixel()`` function returns pixel coordinates outside of the image bounds"]
    #[doc = " if you project a ray toward a point for which there is no recorded data."]
    #[doc = ""]
    #[doc = " ``LeapRectilinearToPixel()`` is typically not fast enough for realtime distortion correction."]
    #[doc = " For better performance, use a shader program executed on a GPU."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param rectilinear A Vector containing the ray direction."]
    #[doc = " @returns A Vector containing the pixel coordinates [x, y, 1] (with z always 1)."]
    #[doc = " @since 3.1.3"]
    pub fn LeapRectilinearToPixel(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        rectilinear: LEAP_VECTOR,
    ) -> LEAP_VECTOR;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Provides the point in the image corresponding to a ray projecting"]
    #[doc = " from the camera for a particular device."]
    #[doc = ""]
    #[doc = " Given a ray projected from the camera in the specified direction, ``LeapRectilinearToPixelEx()``"]
    #[doc = " corrects for camera distortion and returns the corresponding pixel"]
    #[doc = " coordinates in the image."]
    #[doc = ""]
    #[doc = " The ray direction is specified in relationship to the camera. The first"]
    #[doc = " vector element is the tangent of the \"horizontal\" view angle; the second"]
    #[doc = " element is the tangent of the \"vertical\" view angle."]
    #[doc = ""]
    #[doc = " The ``LeapRectilinearToPixelEx()`` function returns pixel coordinates outside of the image bounds"]
    #[doc = " if you project a ray toward a point for which there is no recorded data."]
    #[doc = ""]
    #[doc = " ``LeapRectilinearToPixelEx()`` is typically not fast enough for realtime distortion correction."]
    #[doc = " For better performance, use a shader program executed on a GPU."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param rectilinear A Vector containing the ray direction."]
    #[doc = " @returns A Vector containing the pixel coordinates [x, y, 1] (with z always 1)."]
    #[doc = " @since 5.4.0"]
    pub fn LeapRectilinearToPixelEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        rectilinear: LEAP_VECTOR,
    ) -> LEAP_VECTOR;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Returns an OpenCV-compatible camera matrix."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 9"]
    #[doc = " @since 3.2.1"]
    pub fn LeapCameraMatrix(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Returns an OpenCV-compatible camera matrix for a particular device."]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 9"]
    #[doc = " @since 5.4.0"]
    pub fn LeapCameraMatrixEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " This finds the default device and returns the result LeapExtrinsicCameraMatrixEx()"]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest  A pointer to a single-precision float array of size 16, containing"]
    #[doc = "  the coefficients of the 4x4 matrix in Column Major order"]
    #[doc = " @since 5.1.0"]
    pub fn LeapExtrinsicCameraMatrix(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = ""]
    #[doc = " Returns a transformation matrix from 3D Leap coordinate space to the coordinate system of the requested camera"]
    #[doc = " This is composed of a 4 x 4 matrix of the form:"]
    #[doc = ""]
    #[doc = " R, t <br>"]
    #[doc = " 0, 1"]
    #[doc = ""]
    #[doc = "  R is a 3 x 3 rotation matrix <br>"]
    #[doc = "  t is a 3 x 1 translation vector"]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 16, containing"]
    #[doc = "  the coefficients of the 4x4 matrix in Column Major order"]
    #[doc = " @since 5.1.0"]
    pub fn LeapExtrinsicCameraMatrixEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Returns an OpenCV-compatible lens distortion using the 8-parameter rational"]
    #[doc = " model."]
    #[doc = ""]
    #[doc = " The order of the returned array is: [k1, k2, p1, p2, k3, k4, k5, k6]"]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 8."]
    #[doc = " @since 3.2.1"]
    pub fn LeapDistortionCoeffs(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Returns an OpenCV-compatible lens distortion for a particular device, using"]
    #[doc = " the 8-parameter rational model."]
    #[doc = ""]
    #[doc = " The order of the returned array is: [k1, k2, p1, p2, k3, k4, k5, k6]"]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 8."]
    #[doc = " @since 5.4.0"]
    pub fn LeapDistortionCoeffsEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Provides the human-readable canonical name of the specified device model."]
    #[doc = ""]
    #[doc = " This method is guaranteed to never return null for the LEAP_DEVICE_INFO.pid field"]
    #[doc = " returned by a successful call to LeapGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @param pid The pid of the device"]
    #[doc = " @returns The string name of the device model, or null if the device type string is invalid."]
    #[doc = ""]
    pub fn LeapDevicePIDToString(pid: eLeapDevicePID) -> *const ::std::os::raw::c_char;
}
pub const _eLeapRecordingFlags_eLeapRecordingFlags_Error: _eLeapRecordingFlags = 0;
pub const _eLeapRecordingFlags_eLeapRecordingFlags_Reading: _eLeapRecordingFlags = 1;
pub const _eLeapRecordingFlags_eLeapRecordingFlags_Writing: _eLeapRecordingFlags = 2;
pub const _eLeapRecordingFlags_eLeapRecordingFlags_Flushing: _eLeapRecordingFlags = 4;
pub const _eLeapRecordingFlags_eLeapRecordingFlags_Compressed: _eLeapRecordingFlags = 8;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the recording mode provided to the LeapRecordingOpen()"]
#[doc = " function. Also used in members of LEAP_RECORDING_PARAMETERS and LEAP_RECORDING_STATUS."]
#[doc = " @since 3.2.0"]
pub type _eLeapRecordingFlags = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the recording mode provided to the LeapRecordingOpen()"]
#[doc = " function. Also used in members of LEAP_RECORDING_PARAMETERS and LEAP_RECORDING_STATUS."]
#[doc = " @since 3.2.0"]
pub use self::_eLeapRecordingFlags as eLeapRecordingFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_RECORDING {
    _unused: [u8; 0],
}
#[doc = " \\ingroup Structs"]
#[doc = " A Leap recording."]
#[doc = " @since 3.2.0"]
pub type LEAP_RECORDING = *mut _LEAP_RECORDING;
#[doc = "  \\ingroup Structs"]
#[doc = " Read/Write mode for opening a LEAP_RECORDING."]
#[doc = " since 3.2.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_RECORDING_PARAMETERS {
    #[doc = " A combination of eLeapRecordingFlags indicating the desired operations. @since 3.2.0"]
    pub mode: u32,
}
#[test]
fn bindgen_test_layout__LEAP_RECORDING_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_RECORDING_PARAMETERS>(),
        4usize,
        concat!("Size of: ", stringify!(_LEAP_RECORDING_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_RECORDING_PARAMETERS>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_RECORDING_PARAMETERS))
    );
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_RECORDING_PARAMETERS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_RECORDING_PARAMETERS),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
#[doc = "  \\ingroup Structs"]
#[doc = " Read/Write mode for opening a LEAP_RECORDING."]
#[doc = " since 3.2.0"]
pub type LEAP_RECORDING_PARAMETERS = _LEAP_RECORDING_PARAMETERS;
#[doc = "  \\ingroup Structs"]
#[doc = " Information about a current LEAP_RECORDING."]
#[doc = " Filled in by a call to LeapRecordingGetStatus()."]
#[doc = " @since 3.2.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_RECORDING_STATUS {
    #[doc = " Some combination of eLeapRecordingFlags indicating the status of the recording. @since 3.2.0"]
    pub mode: u32,
}
#[test]
fn bindgen_test_layout__LEAP_RECORDING_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_RECORDING_STATUS>(),
        4usize,
        concat!("Size of: ", stringify!(_LEAP_RECORDING_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_RECORDING_STATUS>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_RECORDING_STATUS))
    );
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_RECORDING_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_RECORDING_STATUS),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
#[doc = "  \\ingroup Structs"]
#[doc = " Information about a current LEAP_RECORDING."]
#[doc = " Filled in by a call to LeapRecordingGetStatus()."]
#[doc = " @since 3.2.0"]
pub type LEAP_RECORDING_STATUS = _LEAP_RECORDING_STATUS;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Opens or creates a LEAP_RECORDING."]
    #[doc = ""]
    #[doc = " Pass the LEAP_RECORDING pointer to LeapRecordingOpen() to initiate reading from"]
    #[doc = " or writing to a recording. The recording path is relative to the \"user path\""]
    #[doc = " which is the SD card on Android."]
    #[doc = ""]
    #[doc = " @param ppRecording The recording being opened."]
    #[doc = " @param filePath The file path. This will be passed directly to the OS without modification. An \".lmt\" suffix is suggested."]
    #[doc = " @param params The LEAP_RECORDING_PARAMETERS describing what operations are requested."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingOpen(
        ppRecording: *mut LEAP_RECORDING,
        filePath: *const ::std::os::raw::c_char,
        params: LEAP_RECORDING_PARAMETERS,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Closes a LEAP_RECORDING."]
    #[doc = ""]
    #[doc = " @param[out] ppRecording The recording being closed. Will modify *ppRecording to be null."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingClose(ppRecording: *mut LEAP_RECORDING) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Fills in a LEAP_RECORDING_STATUS struct for an open recording."]
    #[doc = " This struct provides the applicable eLeapRecordingFlags."]
    #[doc = ""]
    #[doc = " @param pRecording The open recording."]
    #[doc = " @param[out] pstatus A LEAP_RECORDING_STATUS struct to receive the recording status."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingGetStatus(
        pRecording: LEAP_RECORDING,
        pstatus: *mut LEAP_RECORDING_STATUS,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Retrieves the number of bytes required to allocate the next frame in a recording."]
    #[doc = ""]
    #[doc = " Use this function to determine the size of the buffer to allocate before calling"]
    #[doc = " LeapRecordingRead()."]
    #[doc = ""]
    #[doc = " @param pRecording The recording being read from."]
    #[doc = " @param[out] pncbEvent A pointer that receives the number of bytes required to store the next frame."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingReadSize(pRecording: LEAP_RECORDING, pncbEvent: *mut u64) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Reads a tracking frame from a LEAP_RECORDING file."]
    #[doc = ""]
    #[doc = " Caller is responsible for allocating a buffer large enough to hold the data of the frame."]
    #[doc = " Use LeapGetFrameSize() to calculate the minimum size of this buffer."]
    #[doc = ""]
    #[doc = " @param pRecording The recording being read from."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with the next recorded frame."]
    #[doc = " @param ncbEvent The number of bytes pointed to by pEvent."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingRead(
        pRecording: LEAP_RECORDING,
        pEvent: *mut LEAP_TRACKING_EVENT,
        ncbEvent: u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " Writes a tracking frame to a LEAP_RECORDING file."]
    #[doc = ""]
    #[doc = " @param pRecording The recording being written to."]
    #[doc = " @param[out] pEvent A pointer to a flat buffer which is filled with an interpolated frame."]
    #[doc = " @param pnBytesWritten If non-null the number of bytes written."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 3.2.0"]
    pub fn LeapRecordingWrite(
        pRecording: LEAP_RECORDING,
        pEvent: *mut LEAP_TRACKING_EVENT,
        pnBytesWritten: *mut u64,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = " This finds the default device and returns the result of LeapScaleOffsetMatrixEx()"]
    #[doc = " @sa LeapScaleOffsetMatrixEx for additional information"]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest  A pointer to a single-precision float array of size 16, containing"]
    #[doc = "  the coefficients of the 4x4 matrix in Column Major order"]
    #[doc = " @since 5.x.x"]
    pub fn LeapScaleOffsetMatrix(
        hConnection: LEAP_CONNECTION,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = ""]
    #[doc = " Returns the appropriate scale and offset coefficients required to project"]
    #[doc = " normalised Rectilinear coordinates to image-scale coordinates."]
    #[doc = ""]
    #[doc = " This is composed of a 4 x 4 matrix of the form:"]
    #[doc = ""]
    #[doc = " scale_x, 0, 0, offset_x,"]
    #[doc = " 0, 1, 0, 0,"]
    #[doc = " 0, 0, scale_z, offset_z"]
    #[doc = " 0, 0, 0, 1"]
    #[doc = ""]
    #[doc = " This matrix is specific to the size of the current image as contained within LEAP_IMAGE."]
    #[doc = ""]
    #[doc = " In practical terms, use this matrix in combination with normalised rays"]
    #[doc = " to project 3D points into a rectilinear image space (i.e. to visualise hands on an undistorted image)."]
    #[doc = ""]
    #[doc = " The pipeline would be:"]
    #[doc = " 1) Take 3D points from hand tracking."]
    #[doc = " 2) Apply an extrinsic transformation to a specific camera's coordinate system (@sa LeapExtrinsicCameraMatrixEx)"]
    #[doc = " 3) Apply a perspective division to transform 3D points to rays."]
    #[doc = " 4) Apply the ScaleOffset matrix to these points."]
    #[doc = ""]
    #[doc = " These points will now be in the correct coordinate system consistent with the undistorted rectilinear image"]
    #[doc = " provided by LEAP_IMAGE::distortion_matrix."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param hDevice A device handle returned by LeapOpenDevice()."]
    #[doc = " @param camera The camera to use, a member of the eLeapPerspectiveType enumeration"]
    #[doc = " @param[out] dest A pointer to a single-precision float array of size 16, containing"]
    #[doc = "  the coefficients of the 4x4 matrix in Column Major order"]
    #[doc = " @since 5.x.x"]
    pub fn LeapScaleOffsetMatrixEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        camera: eLeapPerspectiveType,
        dest: *mut f32,
    );
}
#[doc = " The parameter for requesting the version of the client."]
#[doc = " @since 5.2.x"]
pub const _eLeapVersionPart_eLeapVersionPart_ClientLibrary: _eLeapVersionPart = 0;
#[doc = " The parameter for requesting the protocol version of the client."]
#[doc = " @since 5.2.x"]
pub const _eLeapVersionPart_eLeapVersionPart_ClientProtocol: _eLeapVersionPart = 1;
#[doc = " The parameter for requesting the version of the server."]
#[doc = " @since 5.2.x"]
pub const _eLeapVersionPart_eLeapVersionPart_ServerLibrary: _eLeapVersionPart = 2;
#[doc = " The parameter for requesting the protocol version of the server."]
#[doc = " @since 5.2.x"]
pub const _eLeapVersionPart_eLeapVersionPart_ServerProtocol: _eLeapVersionPart = 3;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the parameters used to access version information."]
#[doc = " @since 5.2.x"]
pub type _eLeapVersionPart = ::std::os::raw::c_int;
#[doc = " \\ingroup Enum"]
#[doc = " Defines the parameters used to access version information."]
#[doc = " @since 5.2.x"]
pub use self::_eLeapVersionPart as eLeapVersionPart;
#[doc = " \\ingroup Structs"]
#[doc = " Version information."]
#[doc = ""]
#[doc = " The members can be converted to a version string using the format:"]
#[doc = ""]
#[doc = " major.minor.patch.build"]
#[doc = ""]
#[doc = " @since 5.2.0"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_VERSION {
    #[doc = " The major version."]
    #[doc = " @since 5.2.0"]
    pub major: i32,
    #[doc = " The minor version."]
    #[doc = " @since 5.2.0"]
    pub minor: i32,
    #[doc = " The patch version."]
    #[doc = " @since 5.2.0"]
    pub patch: i32,
}
#[test]
fn bindgen_test_layout__LEAP_VERSION() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_VERSION>(),
        12usize,
        concat!("Size of: ", stringify!(_LEAP_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_VERSION>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_VERSION))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VERSION),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VERSION),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_patch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_VERSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_VERSION),
                "::",
                stringify!(patch)
            )
        );
    }
    test_field_patch();
}
#[doc = " \\ingroup Structs"]
#[doc = " Version information."]
#[doc = ""]
#[doc = " The members can be converted to a version string using the format:"]
#[doc = ""]
#[doc = " major.minor.patch.build"]
#[doc = ""]
#[doc = " @since 5.2.0"]
pub type LEAP_VERSION = _LEAP_VERSION;
extern "C" {
    #[doc = " \\ingroup Functions"]
    #[doc = ""]
    #[doc = " Returns the version of a specified part of the system."]
    #[doc = ""]
    #[doc = " If an invalid connection handle is provided only the version details of the client will be available."]
    #[doc = ""]
    #[doc = " @param hConnection The connection handle created by LeapCreateConnection()."]
    #[doc = " @param versionPart The version part to return, this will reference one part of the system."]
    #[doc = " @param[out] pVersion A pointer to a struct used to store the version number."]
    #[doc = " @returns The operation result code, a member of the eLeapRS enumeration."]
    #[doc = " @since 5.2.x"]
    pub fn LeapGetVersion(
        hConnection: LEAP_CONNECTION,
        versionPart: eLeapVersionPart,
        pVersion: *mut LEAP_VERSION,
    ) -> eLeapRS;
}
extern "C" {
    #[doc = " Not Supported:"]
    #[doc = ""]
    #[doc = " The following functions are included for API compatibility with earlier LeapC version."]
    #[doc = " They are no longer supported and calling them will have no effects."]
    pub fn LeapGetPointMappingSize(hConnection: LEAP_CONNECTION, pSize: *mut u64) -> eLeapRS;
}
extern "C" {
    pub fn LeapGetPointMapping(
        hConnection: LEAP_CONNECTION,
        pointMapping: *mut LEAP_POINT_MAPPING,
        pSize: *mut u64,
    ) -> eLeapRS;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _LEAP_TELEMETRY_DATA {
    pub thread_id: u32,
    pub start_time: u64,
    pub end_time: u64,
    pub zone_depth: u32,
    pub file_name: *const ::std::os::raw::c_char,
    pub line_number: u32,
    pub zone_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__LEAP_TELEMETRY_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_LEAP_TELEMETRY_DATA>(),
        44usize,
        concat!("Size of: ", stringify!(_LEAP_TELEMETRY_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_LEAP_TELEMETRY_DATA>(),
        1usize,
        concat!("Alignment of ", stringify!(_LEAP_TELEMETRY_DATA))
    );
    fn test_field_thread_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(thread_id)
            )
        );
    }
    test_field_thread_id();
    fn test_field_start_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_time) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(start_time)
            )
        );
    }
    test_field_start_time();
    fn test_field_end_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_time) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(end_time)
            )
        );
    }
    test_field_end_time();
    fn test_field_zone_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zone_depth) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(zone_depth)
            )
        );
    }
    test_field_zone_depth();
    fn test_field_file_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(file_name)
            )
        );
    }
    test_field_file_name();
    fn test_field_line_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_number) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(line_number)
            )
        );
    }
    test_field_line_number();
    fn test_field_zone_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LEAP_TELEMETRY_DATA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zone_name) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_LEAP_TELEMETRY_DATA),
                "::",
                stringify!(zone_name)
            )
        );
    }
    test_field_zone_name();
}
pub type LEAP_TELEMETRY_DATA = _LEAP_TELEMETRY_DATA;
extern "C" {
    pub fn LeapTelemetryProfiling(
        hConnection: LEAP_CONNECTION,
        telemetryData: *const LEAP_TELEMETRY_DATA,
    ) -> eLeapRS;
}
extern "C" {
    pub fn LeapTelemetryGetNow() -> u64;
}
extern "C" {
    pub fn LeapInterpolateHeadPose(
        hConnection: LEAP_CONNECTION,
        timestamp: i64,
        pEvent: *mut LEAP_HEAD_POSE_EVENT,
    ) -> eLeapRS;
}
extern "C" {
    pub fn LeapInterpolateHeadPoseEx(
        hConnection: LEAP_CONNECTION,
        hDevice: LEAP_DEVICE,
        timestamp: i64,
        pEvent: *mut LEAP_HEAD_POSE_EVENT,
    ) -> eLeapRS;
}
extern "C" {
    pub fn LeapInterpolateEyePositions(
        hConnection: LEAP_CONNECTION,
        timestamp: i64,
        pEvent: *mut LEAP_EYE_EVENT,
    ) -> eLeapRS;
}
